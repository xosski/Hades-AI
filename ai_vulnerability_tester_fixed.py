"""
AI-Powered Vulnerability Testing for Authorized Websites - FIXED VERSION
Properly analyzes responses with header collection and real vulnerability detection
"""

import logging
import json
import time
import threading
from typing import Dict, List, Optional, Tuple
from dataclasses import dataclass, asdict
from datetime import datetime
import requests
from urllib.parse import urlparse, urljoin

logger = logging.getLogger("AIVulnerabilityTester")


@dataclass
class HTTPResponse:
    """Captured HTTP response with all details"""
    status_code: int
    headers: Dict[str, str]
    body: str
    response_time: float
    url: str
    timestamp: float


@dataclass
class VulnerabilityTest:
    """Represents a single vulnerability test"""
    test_id: str
    test_name: str
    test_type: str  # injection, auth, config, etc.
    severity: str
    payload: str
    expected_indicators: List[str]
    requires_auth: bool = False
    timeout: int = 10


@dataclass
class TestResult:
    """Result of a vulnerability test"""
    test_id: str
    test_name: str
    test_type: str
    severity: str
    vulnerable: bool
    confidence: float
    evidence: str
    proof_points: List[str]
    response: HTTPResponse
    payload_used: str
    timestamp: float


class AIVulnerabilityTester:
    """
    AI-powered vulnerability tester for authorized targets
    Uses objective evidence, not keyword matching
    """
    
    VULNERABILITY_TESTS = {
        'injection': [
            VulnerabilityTest(
                'sql_001', 'SQL Injection - Basic',
                'injection', 'Critical',
                "' OR '1'='1'--",
                ["syntax error", "sql", "mysql", "sqlite"],
                False
            ),
            VulnerabilityTest(
                'sql_002', 'SQL Injection - Union',
                'injection', 'Critical',
                "' UNION SELECT NULL,NULL--",
                ["error", "syntax"],
                False
            ),
            VulnerabilityTest(
                'sql_003', 'SQL Injection - Time Delay',
                'injection', 'Critical',
                "'; WAITFOR DELAY '00:00:05'--",
                ["timeout", "delay"],
                False
            ),
            VulnerabilityTest(
                'sql_004', 'SQL Injection - Boolean',
                'injection', 'Critical',
                "' AND 1=1--",
                ["error", "syntax"],
                False
            ),
            VulnerabilityTest(
                'xss_001', 'XSS - Basic Script',
                'injection', 'High',
                '<img src=x onerror="alert(1)">',
                ["alert", "onerror", "script"],
                False
            ),
            VulnerabilityTest(
                'xss_002', 'XSS - Event Handler',
                'injection', 'High',
                '"><svg onload="alert(1)">',
                ["svg", "onload", "alert"],
                False
            ),
            VulnerabilityTest(
                'xss_003', 'XSS - DOM-based',
                'injection', 'High',
                '<img src=x onerror="eval(decodeURIComponent(location.hash))">',
                ["eval", "decodeURIComponent"],
                False
            ),
            VulnerabilityTest(
                'xss_004', 'XSS - JavaScript Protocol',
                'injection', 'High',
                '<a href="javascript:alert(1)">click</a>',
                ["javascript", "alert"],
                False
            ),
            VulnerabilityTest(
                'cmd_001', 'Command Injection',
                'injection', 'Critical',
                "; ls -la #",
                ["total", "drwx", "permission denied"],
                False
            ),
            VulnerabilityTest(
                'ldap_001', 'LDAP Injection',
                'injection', 'High',
                "*)(uid=*",
                ["ldap", "filter"],
                False
            ),
        ],
        'headers': [
            VulnerabilityTest(
                'header_001', 'Missing HSTS Header',
                'headers', 'High',
                '',
                [],
                False
            ),
            VulnerabilityTest(
                'header_002', 'Missing CSP Header',
                'headers', 'Medium',
                '',
                [],
                False
            ),
            VulnerabilityTest(
                'header_003', 'Missing X-Frame-Options',
                'headers', 'Medium',
                '',
                [],
                False
            ),
            VulnerabilityTest(
                'header_004', 'CORS Allow Any Origin',
                'headers', 'High',
                '',
                ['access-control-allow-origin: *'],
                False
            ),
            VulnerabilityTest(
                'header_005', 'Missing X-Content-Type-Options',
                'headers', 'Medium',
                '',
                [],
                False
            ),
            VulnerabilityTest(
                'header_006', 'Missing Strict-Transport-Security',
                'headers', 'High',
                '',
                [],
                False
            ),
            VulnerabilityTest(
                'header_007', 'Server Header Exposed',
                'headers', 'Low',
                '',
                ['server', 'apache', 'nginx', 'iis'],
                False
            ),
        ],
        'cookie_security': [
            VulnerabilityTest(
                'cookie_001', 'Missing HttpOnly Flag',
                'cookie_security', 'High',
                '',
                [],
                False
            ),
            VulnerabilityTest(
                'cookie_002', 'Missing Secure Flag (HTTPS)',
                'cookie_security', 'High',
                '',
                [],
                False
            ),
            VulnerabilityTest(
                'cookie_003', 'Missing SameSite Attribute',
                'cookie_security', 'Medium',
                '',
                [],
                False
            ),
            VulnerabilityTest(
                'cookie_004', 'Weak Session Tokens',
                'cookie_security', 'High',
                '',
                ['sessionid=123', 'jsessionid=abc'],
                False
            ),
        ],
        'configuration': [
            VulnerabilityTest(
                'config_001', 'Admin Panel Accessible',
                'configuration', 'Critical',
                '/admin',
                [],
                False
            ),
            VulnerabilityTest(
                'config_002', 'Backup Files Exposed',
                'configuration', 'High',
                '/.backup',
                [],
                False
            ),
            VulnerabilityTest(
                'config_003', 'Git Directory Exposed',
                'configuration', 'High',
                '/.git/config',
                [],
                False
            ),
            VulnerabilityTest(
                'config_004', 'XML-RPC Enabled',
                'configuration', 'Medium',
                '/xmlrpc.php',
                ['xmlrpc'],
                False
            ),
            VulnerabilityTest(
                'config_005', 'Web.config Accessible',
                'configuration', 'Critical',
                '/web.config',
                ['configuration', 'connectionString'],
                False
            ),
            VulnerabilityTest(
                'config_006', 'Debug Mode Enabled',
                'configuration', 'High',
                '',
                ['debug', 'debugger'],
                False
            ),
        ],
        'access_control': [
            VulnerabilityTest(
                'acl_001', 'Unauth Admin Access',
                'access_control', 'Critical',
                '/admin/users',
                [],
                False
            ),
            VulnerabilityTest(
                'acl_002', 'Path Traversal',
                'access_control', 'High',
                '/../../../etc/passwd',
                ['root:', 'bin/', 'nobody'],
                False
            ),
            VulnerabilityTest(
                'acl_003', 'Privilege Escalation',
                'access_control', 'Critical',
                '/admin/settings',
                [],
                False
            ),
        ],
        'authentication': [
            VulnerabilityTest(
                'auth_001', 'Default Credentials',
                'authentication', 'Critical',
                '/login',
                ['admin', 'password'],
                False
            ),
            VulnerabilityTest(
                'auth_002', 'Weak Password Policy',
                'authentication', 'High',
                '',
                ['password', '123456', 'weak'],
                False
            ),
            VulnerabilityTest(
                'auth_003', 'No Account Lockout',
                'authentication', 'High',
                '',
                ['brute force', 'attempts'],
                False
            ),
            VulnerabilityTest(
                'auth_004', 'Session Fixation',
                'authentication', 'High',
                '',
                [],
                False
            ),
        ],
        'api_security': [
            VulnerabilityTest(
                'api_001', 'Unprotected API Endpoints',
                'api_security', 'High',
                '/api/users',
                ['json', 'data'],
                False
            ),
            VulnerabilityTest(
                'api_002', 'Missing API Rate Limiting',
                'api_security', 'Medium',
                '/api/data',
                [],
                False
            ),
            VulnerabilityTest(
                'api_003', 'Insecure API Keys',
                'api_security', 'High',
                '/api/config',
                ['api_key', 'secret'],
                False
            ),
        ],
        'methods': [
            VulnerabilityTest(
                'methods_001', 'HTTP Methods Exposed',
                'methods', 'Medium',
                '',
                [],
                False
            ),
            VulnerabilityTest(
                'methods_002', 'PUT/DELETE Methods Allowed',
                'methods', 'High',
                '',
                [],
                False
            ),
        ],
    }
    
    def __init__(self, hades_ai=None, target_url: str = ''):
        self.hades_ai = hades_ai
        self.target_url = target_url
        self.test_results: List[TestResult] = []
        self.session = requests.Session()
        self.session.headers.update({
            'User-Agent': 'Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36'
        })
        self.timeout = 10
    
    def test_website(self, target_url: str, test_categories: List[str] = None, 
                    callback: Optional[callable] = None) -> Dict:
        """
        Run comprehensive tests on target URL
        Returns detailed results with HTTP evidence
        """
        self.target_url = target_url.rstrip('/')
        self.test_results = []
        
        # Validate URL
        try:
            parsed = urlparse(target_url)
            if not parsed.scheme:
                target_url = f"https://{target_url}"
                self.target_url = target_url
        except:
            return {'error': 'Invalid URL format', 'target': target_url}
        
        if callback:
            callback(f"Starting security assessment of {self.target_url}")
        
        # Run tests by category
        test_categories = test_categories or list(self.VULNERABILITY_TESTS.keys())
        total_tests = sum(len(self.VULNERABILITY_TESTS[cat]) for cat in test_categories if cat in self.VULNERABILITY_TESTS)
        tests_run = 0
        
        for category in test_categories:
            if category not in self.VULNERABILITY_TESTS:
                continue
                
            if callback:
                callback(f"\n>>> Testing {category.upper()} ({len(self.VULNERABILITY_TESTS[category])} tests)")
            
            tests = self.VULNERABILITY_TESTS[category]
            for test in tests:
                if callback:
                    callback(f"  [{tests_run + 1}/{total_tests}] {test.test_name}...")
                self._run_test(test, callback)
                tests_run += 1
        
        if callback:
            callback(f"\n>>> Assessment complete - {tests_run} tests run, {len([r for r in self.test_results if r.vulnerable])} vulnerabilities found")
        
        return self._compile_findings()
    
    def _run_test(self, test: VulnerabilityTest, callback: Optional[callable] = None):
        """Run a single vulnerability test"""
        try:
            url = self._build_test_url(test)
            
            start_time = time.time()
            response = self.session.get(
                url, 
                timeout=self.timeout,
                allow_redirects=True,
                verify=False
            )
            response_time = time.time() - start_time
            
            # Capture full response details
            http_response = HTTPResponse(
                status_code=response.status_code,
                headers=dict(response.headers),
                body=response.text[:5000],  # First 5KB
                response_time=response_time,
                url=response.url,
                timestamp=time.time()
            )
            
            # Analyze for real vulnerabilities
            is_vulnerable, confidence, proof_points = self._analyze_response(test, http_response)
            
            result = TestResult(
                test_id=test.test_id,
                test_name=test.test_name,
                test_type=test.test_type,
                severity=test.severity,
                vulnerable=is_vulnerable,
                confidence=confidence,
                evidence="See HTTP response and proof points",
                proof_points=proof_points,
                response=http_response,
                payload_used=test.payload,
                timestamp=time.time()
            )
            
            self.test_results.append(result)
            
            # Report every test result
            if callback:
                status = "VULNERABLE" if is_vulnerable else "OK"
                conf_str = f"{confidence:.0%}" if is_vulnerable else "SAFE"
                callback(f"      Result: {status} | {test.test_name} | Confidence: {conf_str} | HTTP {response.status_code}")
        
        except requests.exceptions.Timeout:
            if callback:
                callback(f"      ERROR: Test {test.test_id} timed out (>{self.timeout}s)")
            logger.warning(f"Test {test.test_id} timed out")
        except requests.exceptions.ConnectionError as e:
            if callback:
                callback(f"      ERROR: Connection failed - {str(e)[:50]}")
            logger.error(f"Connection error for {test.test_id}: {e}")
        except Exception as e:
            if callback:
                callback(f"      ERROR: Test {test.test_id} failed - {str(e)[:50]}")
            logger.error(f"Error in test {test.test_id}: {e}")
            import traceback
            traceback.print_exc()
    
    def _build_test_url(self, test: VulnerabilityTest) -> str:
        """Build URL with test payload"""
        base_url = self.target_url
        
        if not test.payload:
            return base_url
        
        # Config/path tests - append to path
        if test.test_type in ['config', 'access_control']:
            return urljoin(base_url, test.payload)
        
        # Injection tests - add to query params
        if test.test_type == 'injection':
            param = test.payload
            if '?' in base_url:
                return f"{base_url}&q={param}"
            else:
                return f"{base_url}?q={param}"
        
        return base_url
    
    def _analyze_response(self, test: VulnerabilityTest, 
                         response: HTTPResponse) -> Tuple[bool, float, List[str]]:
        """
        Analyze response for REAL vulnerability evidence
        Not keyword matching - objective criteria
        """
        proof_points = []
        is_vulnerable = False
        confidence = 0.0
        
        # === HEADER SECURITY TESTS ===
        if test.test_type == 'headers':
            headers_lower = {k.lower(): v.lower() for k, v in response.headers.items()}
            
            if test.test_id == 'header_001':  # Missing HSTS
                if 'strict-transport-security' not in headers_lower:
                    is_vulnerable = True
                    confidence = 0.9
                    proof_points.append("HSTS header missing - site not forcing HTTPS")
                    proof_points.append(f"Requested URL: {response.url}")
                    proof_points.append("Response status: HTTP 200 (page served)")
                    proof_points.append("Missing header: Strict-Transport-Security")
                    proof_points.append("Impact: Browsers won't enforce HTTPS on return visits")
                    proof_points.append("Attack vector: HTTP downgrade attacks, MITM interception")
            
            elif test.test_id == 'header_002':  # Missing CSP
                if 'content-security-policy' not in headers_lower:
                    is_vulnerable = True
                    confidence = 0.8
                    proof_points.append("CSP header missing - vulnerable to XSS")
                    proof_points.append(f"Endpoint: {response.url}")
                    proof_points.append("Missing: Content-Security-Policy header")
                    proof_points.append("Impact: Inline scripts can execute freely")
                    proof_points.append("Risk: XSS attacks have greater impact on this site")
            
            elif test.test_id == 'header_003':  # Missing X-Frame-Options
                if 'x-frame-options' not in headers_lower:
                    is_vulnerable = True
                    confidence = 0.7
                    proof_points.append("X-Frame-Options missing - vulnerable to clickjacking")
                    proof_points.append(f"Endpoint: {response.url}")
                    proof_points.append("Missing: X-Frame-Options header")
                    proof_points.append("Attack: Attacker can embed page in iframe and trick users")
                    proof_points.append("Mitigation: Add header: X-Frame-Options: DENY")
            
            elif test.test_id == 'header_004':  # CORS Allow Any
                cors_header = headers_lower.get('access-control-allow-origin', '')
                if cors_header == '*':
                    is_vulnerable = True
                    confidence = 1.0
                    proof_points.append(f"CORS allows any origin: Access-Control-Allow-Origin: *")
                    proof_points.append(f"Endpoint: {response.url}")
                    proof_points.append("Any website can make cross-origin requests to this site")
                    proof_points.append("Sensitive data can be exfiltrated by malicious websites")
                    proof_points.append("Possible exposed endpoints: /api/*, /user/*, /admin/*")
        
        # === COOKIE SECURITY TESTS ===
        elif test.test_type == 'cookie_security':
            set_cookie = response.headers.get('Set-Cookie', '')
            set_cookie_lower = set_cookie.lower()
            
            if test.test_id == 'cookie_001':  # Missing HttpOnly
                if set_cookie and 'httponly' not in set_cookie_lower:
                    is_vulnerable = True
                    confidence = 0.95
                    proof_points.append(f"Found vulnerable cookie: {set_cookie.split(';')[0] if set_cookie else 'Session'}")
                    proof_points.append(f"Full Set-Cookie header: {set_cookie[:100]}...")
                    proof_points.append("Missing flag: HttpOnly")
                    proof_points.append("Impact: JavaScript can access this cookie")
                    proof_points.append("XSS Attack scenario: Malicious script steals session cookie via document.cookie")
                    proof_points.append("Attacker can impersonate user without needing password")
            
            elif test.test_id == 'cookie_002':  # Missing Secure
                if set_cookie and 'secure' not in set_cookie_lower:
                    is_vulnerable = True
                    confidence = 0.95
                    proof_points.append(f"Found vulnerable cookie: {set_cookie.split(';')[0] if set_cookie else 'Session'}")
                    proof_points.append(f"Full Set-Cookie header: {set_cookie[:100]}...")
                    proof_points.append("Missing flag: Secure")
                    proof_points.append("Impact: Cookie can be sent over unencrypted HTTP")
                    proof_points.append("Attack scenario: Man-in-the-middle can intercept cookie in transit")
                    proof_points.append("Risk: Session hijacking via network sniffing")
            
            elif test.test_id == 'cookie_003':  # Missing SameSite
                if set_cookie and 'samesite' not in set_cookie_lower:
                    is_vulnerable = True
                    confidence = 0.8
                    proof_points.append(f"Found cookie without SameSite: {set_cookie.split(';')[0] if set_cookie else 'Session'}")
                    proof_points.append(f"Current Set-Cookie: {set_cookie[:100]}...")
                    proof_points.append("Missing attribute: SameSite")
                    proof_points.append("CSRF Attack scenario: Attacker tricks user into clicking malicious link")
                    proof_points.append("Cookie sent automatically with cross-site request")
                    proof_points.append("Mitigation: Add SameSite=Strict or SameSite=Lax")
        
        # === CONFIGURATION TESTS ===
        elif test.test_type == 'config':
            if response.status_code == 200:
                body_lower = response.body.lower()
                
                if test.test_id == 'config_001':  # /admin accessible
                    # Check if it's actual login form, not 404 with 200 status
                    has_login_form = any(x in body_lower for x in [
                        '<form', 'login', 'password', 'authenticate', '<input type="password'
                    ])
                    if has_login_form:
                        is_vulnerable = True
                        confidence = 0.85
                        proof_points.append(f"Admin panel accessible at {response.url}")
                        proof_points.append("Authentication form detected")
                        proof_points.append(f"HTTP {response.status_code} response")
                
                elif test.test_id == 'config_002':  # /.backup
                    if response.status_code == 200 and len(response.body) > 10:
                        is_vulnerable = True
                        confidence = 0.95
                        proof_points.append(f"Backup file/directory accessible at: {response.url}")
                        proof_points.append(f"File size: {len(response.body):,} bytes")
                        
                        # Check what type of backup it is
                        body_lower = response.body.lower()
                        if 'tar' in body_lower or 'gzip' in body_lower:
                            proof_points.append("TAR archive detected - contains multiple files")
                        elif 'pk\x03\x04' in response.body[:10]:  # ZIP magic bytes
                            proof_points.append("ZIP archive detected - compressed backup")
                        elif 'index of' in body_lower:
                            proof_points.append("Directory listing exposed - can browse backup contents")
                        elif any(x in body_lower for x in ['.php', '.js', '.py', '.java', 'password', 'api_key', 'token']):
                            proof_points.append("Source code or credentials possibly exposed in backup")
                        
                        # Show response headers indicating file download
                        headers_lower = {k.lower(): v for k, v in response.headers.items()}
                        if 'content-disposition' in headers_lower:
                            proof_points.append(f"Server serving as download: {headers_lower['content-disposition']}")
                        if 'content-type' in headers_lower:
                            proof_points.append(f"File type: {headers_lower['content-type']}")
                
                elif test.test_id == 'config_003':  # /.git/config
                    if response.status_code == 200:
                        is_vulnerable = True
                        confidence = 0.98
                        proof_points.append(f".git directory exposed at: {response.url}")
                        proof_points.append("Git repository configuration file accessible without authentication")
                        
                        # Try to extract git info from response
                        body_lower = response.body.lower()
                        if '[core]' in body_lower:
                            proof_points.append("Git configuration file returned - full repo access possible")
                        if 'repositoryformatversion' in body_lower:
                            proof_points.append("Repository format information exposed")
                        if 'bare' in body_lower or 'worktree' in body_lower:
                            proof_points.append("Repository directory structure information disclosed")
                        
                        proof_points.append("Attacker can clone entire repository and access all commit history")
        
        # === INJECTION TESTS ===
        elif test.test_type == 'injection':
            # Only flag if we get an actual error response showing the injection
            if response.status_code in [500, 502]:
                is_vulnerable = True
                confidence = 0.7
                proof_points.append(f"HTTP {response.status_code} server error received with injection payload")
                proof_points.append(f"Tested URL: {response.url}")
                proof_points.append("Server error suggests payload was processed by application")
                proof_points.append("Impact: Attacker can manipulate queries, extract data, or execute code")
                if 'sql' in test.test_id.lower():
                    proof_points.append("Attack: SQL injection - database query manipulation")
                    proof_points.append("Potential: Data exfiltration, authentication bypass, file write")
                else:
                    proof_points.append("Attack: Script injection - execute malicious code")
            
            # Check for SQL errors in response
            elif response.status_code == 200:
                body_lower = response.body.lower()
                sql_errors = ['syntax error', 'unexpected end of file', 'mysql', 'sql error', 'parse error']
                sql_match = [e for e in sql_errors if e in body_lower]
                
                if sql_match:
                    is_vulnerable = True
                    confidence = 0.9
                    proof_points.append(f"Database error message in response: '{sql_match[0]}'")
                    proof_points.append(f"Tested URL: {response.url}")
                    proof_points.append(f"Injection payload: {test.payload[:50]}...")
                    proof_points.append("Error indicates SQL query was altered by injection")
                    proof_points.append("Attacker can: Extract sensitive data, modify database, bypass authentication")
        
        # === ACCESS CONTROL TESTS ===
        elif test.test_type == 'access_control':
            # Check if we can access admin-only resources without auth
            if response.status_code == 200:
                admin_keywords = ['admin', 'user', 'permission', 'role']
                has_admin_content = any(kw in response.body.lower() for kw in admin_keywords)
                
                if has_admin_content:
                    is_vulnerable = True
                    confidence = 0.8
                    proof_points.append(f"Unauthenticated access to admin endpoint: {response.url}")
                    proof_points.append("Admin-related content returned without authentication")
                    proof_points.append(f"HTTP {response.status_code} response (should require auth)")
                    
                    # Identify what admin content was found
                    body_lower = response.body.lower()
                    if 'user' in body_lower:
                        proof_points.append("Found: User management interface accessible")
                    if 'permission' in body_lower or 'role' in body_lower:
                        proof_points.append("Found: Permission/role management accessible")
                    if 'admin' in body_lower and 'panel' in body_lower:
                        proof_points.append("Found: Admin panel accessible without login")
                    
                    proof_points.append("Impact: Attacker can view/modify admin functions")
                    proof_points.append("Attack: Access user accounts, change settings, delete data")
        
        # === HTTP METHODS TEST ===
        elif test.test_type == 'methods':
            allow_header = response.headers.get('Allow', '')
            dangerous_methods = []
            if 'PUT' in allow_header:
                dangerous_methods.append('PUT')
            if 'DELETE' in allow_header:
                dangerous_methods.append('DELETE')
            if 'TRACE' in allow_header:
                dangerous_methods.append('TRACE')
            
            if allow_header and dangerous_methods:
                is_vulnerable = True
                confidence = 0.6
                proof_points.append(f"Allow header exposes dangerous methods: {allow_header}")
                proof_points.append(f"Endpoint: {response.url}")
                proof_points.append(f"Dangerous methods enabled: {', '.join(dangerous_methods)}")
                
                if 'PUT' in dangerous_methods:
                    proof_points.append("PUT method: Attacker can upload/overwrite files")
                if 'DELETE' in dangerous_methods:
                    proof_points.append("DELETE method: Attacker can delete critical files/data")
                if 'TRACE' in dangerous_methods:
                    proof_points.append("TRACE method: Attacker can perform cross-site tracing attacks")
                
                proof_points.append("Attack: Send HTTP request with dangerous method to modify/delete data")
                proof_points.append("Mitigation: Disable unnecessary HTTP methods (PUT, DELETE, TRACE)")
        
        return is_vulnerable, confidence, proof_points
    
    def _compile_findings(self) -> Dict:
        """Compile results into structured findings"""
        findings = []
        vulnerable_results = [r for r in self.test_results if r.vulnerable]
        
        # Include all results for comprehensive reporting
        for result in self.test_results:
            finding = {
                'id': result.test_id,
                'title': result.test_name,
                'type': result.test_type,
                'severity': result.severity,
                'confidence': f"{result.confidence:.0%}" if result.vulnerable else "0%",
                'status': 'VULNERABLE' if result.vulnerable else 'PASS',
                'vulnerable': result.vulnerable,
                'description': f"Security assessment - {result.test_name}",
                'impact': self._get_impact(result.test_id) if result.vulnerable else "No immediate impact",
                'proof_points': result.proof_points if result.vulnerable else ["Test executed successfully"],
                'payload': result.payload_used if result.vulnerable else "N/A",
                'http_evidence': {
                    'url': result.response.url,
                    'method': 'GET',
                    'status_code': result.response.status_code,
                    'response_time': f"{result.response.response_time:.2f}s",
                    'headers': result.response.headers,
                    'body_sample': result.response.body[:1000]
                } if result.response else {},
                'source': 'AIVulnerabilityTester',
                'timestamp': result.timestamp
            }
            findings.append(finding)
        
        return {
            'target': self.target_url,
            'timestamp': time.time(),
            'generated_date': datetime.now().isoformat(),
            'total_vulnerabilities': len(vulnerable_results),
            'total_tests_run': len(self.test_results),
            'findings': findings,
            'all_results': findings,  # Include all for detailed reporting
            'severity_summary': self._get_severity_summary(vulnerable_results),
            'metadata': {
                'tool': 'AIVulnerabilityTester',
                'scanner_version': '2.0-FIXED',
                'authorization_note': 'This assessment was conducted with proper authorization.',
                'assessment_date': datetime.now().strftime('%Y-%m-%d %H:%M:%S')
            }
        }
    
    def _get_impact(self, test_id: str) -> str:
        """Get impact description for vulnerability"""
        impacts = {
            'header_001': 'Attackers can perform man-in-the-middle attacks on HTTPS connections',
            'header_002': 'XSS vulnerabilities may not be mitigated',
            'header_004': 'Any website can make requests to this domain',
            'cookie_001': 'JavaScript can access session cookies, enabling XSS attacks',
            'cookie_002': 'Cookies transmitted in plaintext over HTTP',
            'cookie_003': 'CSRF attacks are possible',
            'config_001': 'Admin panel may be brute-forced or exploited',
            'config_002': 'Source code and sensitive data exposed',
            'config_003': 'Complete repository history accessible',
            'acl_001': 'Unauthorized access to admin functions',
            'sql_001': 'Database injection and data exfiltration',
        }
        return impacts.get(test_id, 'Security compromise possible')
    
    def _get_severity_summary(self, vulnerabilities: List[TestResult]) -> Dict:
        """Count vulnerabilities by severity"""
        summary = {'Critical': 0, 'High': 0, 'Medium': 0, 'Low': 0}
        for vuln in vulnerabilities:
            severity = vuln.severity
            if severity in summary:
                summary[severity] += 1
        return summary
    
    def export_results(self, filename: str = None) -> str:
        """Export detailed findings"""
        if not filename:
            timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
            filename = f"security_assessment_{timestamp}.json"
        
        findings = self._compile_findings()
        with open(filename, 'w') as f:
            json.dump(findings, f, indent=2)
        
        logger.info(f"Assessment exported to {filename}")
        return filename
    
    def get_remediation_recommendations(self) -> Dict:
        """Generate AI-powered remediation recommendations"""
        vulnerabilities = [r for r in self.test_results if r.vulnerable]
        
        recommendations = {
            'critical': [],
            'high': [],
            'medium': [],
            'low': []
        }
        
        # Add remediation for each vulnerability
        for vuln in vulnerabilities:
            if 'sql' in vuln.test_id.lower():
                recommendations['critical'].append({
                    'vulnerability': vuln.test_name,
                    'fix': 'Use parameterized queries and prepared statements',
                    'priority': 'CRITICAL'
                })
            elif 'xss' in vuln.test_id.lower():
                recommendations['high'].append({
                    'vulnerability': vuln.test_name,
                    'fix': 'Implement input validation, output encoding, and Content Security Policy',
                    'priority': 'HIGH'
                })
            elif 'auth' in vuln.test_id.lower():
                recommendations['high'].append({
                    'vulnerability': vuln.test_name,
                    'fix': 'Enforce strong passwords, implement MFA, disable default credentials',
                    'priority': 'HIGH'
                })
            elif 'config' in vuln.test_id.lower():
                recommendations['high'].append({
                    'vulnerability': vuln.test_name,
                    'fix': 'Disable debug modes, remove admin panels from public access',
                    'priority': 'HIGH'
                })
        
        return recommendations
