"""
Exploit Tome GUI - Interactive interface for managing active exploits
"""

import json
from datetime import datetime
from typing import Optional, List, Dict
from pathlib import Path

from PyQt6.QtWidgets import (
    QWidget, QVBoxLayout, QHBoxLayout, QPushButton, QTextEdit, QLabel,
    QTableWidget, QTableWidgetItem, QLineEdit, QComboBox, QSpinBox,
    QCheckBox, QGroupBox, QFormLayout, QTabWidget, QPlainTextEdit,
    QHeaderView, QMessageBox, QFileDialog, QProgressBar, QListWidget,
    QListWidgetItem, QSplitter, QTreeWidget, QTreeWidgetItem
)
from PyQt6.QtCore import Qt, QThread, pyqtSignal, QTimer
from PyQt6.QtGui import QFont, QColor, QTextCharFormat

from exploit_tome import ExploitTome, ExploitEntry


class ExploitTomeTab(QWidget):
    """Main GUI tab for the Exploit Tome"""
    
    def __init__(self, db_path: str = "exploit_tome.db"):
        super().__init__()
        self.tome = ExploitTome(db_path)
        self.current_exploit_id = None
        self.init_ui()
        self.refresh_all()
    
    def init_ui(self):
        """Initialize the UI"""
        layout = QVBoxLayout(self)
        
        # Create tab widget for different views
        tabs = QTabWidget()
        
        # Tab 1: Active Exploits View
        tabs.addTab(self._create_exploits_tab(), "ðŸ“š Active Exploits")
        
        # Tab 2: Add/Edit Exploit
        tabs.addTab(self._create_edit_tab(), "âž• Add/Edit Exploit")
        
        # Tab 3: Statistics
        tabs.addTab(self._create_stats_tab(), "ðŸ“Š Statistics")
        
        # Tab 4: Collections
        tabs.addTab(self._create_collections_tab(), "ðŸ“ Collections")
        
        # Tab 5: Execution History
        tabs.addTab(self._create_history_tab(), "â±ï¸ Execution History")
        
        layout.addWidget(tabs)
    
    # ========== TAB: ACTIVE EXPLOITS ==========
    
    def _create_exploits_tab(self) -> QWidget:
        widget = QWidget()
        layout = QVBoxLayout(widget)
        
        # Search and filter controls
        control_layout = QHBoxLayout()
        
        self.search_input = QLineEdit()
        self.search_input.setPlaceholderText("ðŸ” Search exploits...")
        self.search_input.textChanged.connect(self._filter_exploits)
        control_layout.addWidget(self.search_input)
        
        self.status_filter = QComboBox()
        self.status_filter.addItems(["All Status", "active", "archived", "testing"])
        self.status_filter.currentTextChanged.connect(self._filter_exploits)
        control_layout.addWidget(self.status_filter)
        
        self.category_filter = QComboBox()
        self.category_filter.addItem("All Categories")
        self.category_filter.currentTextChanged.connect(self._filter_exploits)
        control_layout.addWidget(self.category_filter)
        
        refresh_btn = QPushButton("ðŸ”„ Refresh")
        refresh_btn.clicked.connect(self._refresh_exploits_list)
        control_layout.addWidget(refresh_btn)
        
        layout.addLayout(control_layout)
        
        # Exploits table
        self.exploits_table = QTableWidget()
        self.exploits_table.setColumnCount(7)
        self.exploits_table.setHorizontalHeaderLabels([
            "Name", "Category", "Target", "Success Rate", 
            "Status", "Created", "Actions"
        ])
        self.exploits_table.horizontalHeader().setSectionResizeMode(QHeaderView.ResizeMode.Stretch)
        self.exploits_table.itemClicked.connect(self._on_exploit_selected)
        layout.addWidget(self.exploits_table)
        
        # Details panel
        details_group = QGroupBox("Exploit Details")
        details_layout = QVBoxLayout(details_group)
        
        # Details splitter
        splitter = QSplitter(Qt.Orientation.Horizontal)
        
        # Left side - info
        info_layout = QVBoxLayout()
        self.exploit_info = QLabel("")
        self.exploit_info.setWordWrap(True)
        self.exploit_info.setFont(QFont("Consolas", 9))
        info_layout.addWidget(self.exploit_info)
        
        info_widget = QWidget()
        info_widget.setLayout(info_layout)
        splitter.addWidget(info_widget)
        
        # Right side - code
        code_layout = QVBoxLayout()
        self.exploit_code_display = QPlainTextEdit()
        self.exploit_code_display.setReadOnly(True)
        self.exploit_code_display.setFont(QFont("Consolas", 9))
        code_layout.addWidget(QLabel("Payload:"))
        code_layout.addWidget(self.exploit_code_display)
        
        code_widget = QWidget()
        code_widget.setLayout(code_layout)
        splitter.addWidget(code_widget)
        
        splitter.setStretchFactor(0, 1)
        splitter.setStretchFactor(1, 1)
        
        details_layout.addWidget(splitter)
        
        # Action buttons
        action_layout = QHBoxLayout()
        
        edit_btn = QPushButton("âœï¸ Edit")
        edit_btn.clicked.connect(self._edit_selected_exploit)
        action_layout.addWidget(edit_btn)
        
        clone_btn = QPushButton("ðŸ“‹ Clone")
        clone_btn.clicked.connect(self._clone_exploit)
        action_layout.addWidget(clone_btn)
        
        delete_btn = QPushButton("ðŸ—‘ï¸ Delete")
        delete_btn.clicked.connect(self._delete_selected_exploit)
        delete_btn.setStyleSheet("background: #e94560;")
        action_layout.addWidget(delete_btn)
        
        archive_btn = QPushButton("ðŸ“¦ Archive")
        archive_btn.clicked.connect(self._archive_exploit)
        action_layout.addWidget(archive_btn)
        
        export_single_btn = QPushButton("ðŸ’¾ Export")
        export_single_btn.clicked.connect(self._export_single_exploit)
        action_layout.addWidget(export_single_btn)
        
        details_layout.addLayout(action_layout)
        
        layout.addWidget(details_group)
        
        # Export/Import buttons
        io_layout = QHBoxLayout()
        
        export_all_btn = QPushButton("ðŸ“¤ Export All")
        export_all_btn.clicked.connect(self._export_all_exploits)
        io_layout.addWidget(export_all_btn)
        
        import_btn = QPushButton("ðŸ“¥ Import from JSON")
        import_btn.clicked.connect(self._import_exploits)
        io_layout.addWidget(import_btn)
        
        io_layout.addStretch()
        
        layout.addLayout(io_layout)
        
        return widget
    
    # ========== TAB: ADD/EDIT EXPLOIT ==========
    
    def _create_edit_tab(self) -> QWidget:
        widget = QWidget()
        layout = QVBoxLayout(widget)
        
        form_group = QGroupBox("Exploit Information")
        form_layout = QFormLayout(form_group)
        
        self.edit_name = QLineEdit()
        form_layout.addRow("Name:", self.edit_name)
        
        self.edit_category = QLineEdit()
        self.edit_category.setPlaceholderText("e.g., SQL Injection, XSS, RCE")
        form_layout.addRow("Category:", self.edit_category)
        
        self.edit_target = QLineEdit()
        self.edit_target.setPlaceholderText("e.g., http://target.com/vulnerable.php")
        form_layout.addRow("Target URL:", self.edit_target)
        
        self.edit_notes = QTextEdit()
        self.edit_notes.setMaximumHeight(100)
        form_layout.addRow("Notes:", self.edit_notes)
        
        layout.addWidget(form_group)
        
        # Payload section
        payload_group = QGroupBox("Exploit Payload")
        payload_layout = QVBoxLayout(payload_group)
        
        self.edit_payload = QPlainTextEdit()
        self.edit_payload.setFont(QFont("Consolas", 10))
        self.edit_payload.setMinimumHeight(200)
        self.edit_payload.setPlaceholderText(
            "Enter your exploit payload here...\n\n"
            "Examples:\n"
            "  curl -X POST http://target.com/api -d 'cmd=id'\n"
            "  python3 exploit.py --target http://target.com\n"
            "  <script>alert('XSS')</script>"
        )
        payload_layout.addWidget(self.edit_payload)
        layout.addWidget(payload_group)
        
        # CVE and references
        ref_group = QGroupBox("References")
        ref_layout = QFormLayout(ref_group)
        
        self.edit_cve = QLineEdit()
        self.edit_cve.setPlaceholderText("CVE-2024-XXXXX (comma separated)")
        ref_layout.addRow("CVE IDs:", self.edit_cve)
        
        self.edit_reference_links = QPlainTextEdit()
        self.edit_reference_links.setMaximumHeight(80)
        self.edit_reference_links.setPlaceholderText("References (one per line)")
        ref_layout.addRow("References:", self.edit_reference_links)
        
        self.edit_tags = QLineEdit()
        self.edit_tags.setPlaceholderText("Tags (comma separated)")
        ref_layout.addRow("Tags:", self.edit_tags)
        
        layout.addWidget(ref_group)
        
        # Buttons
        btn_layout = QHBoxLayout()
        
        save_btn = QPushButton("ðŸ’¾ Save Exploit")
        save_btn.clicked.connect(self._save_exploit)
        btn_layout.addWidget(save_btn)
        
        clear_btn = QPushButton("ðŸ”„ Clear")
        clear_btn.clicked.connect(self._clear_edit_form)
        btn_layout.addWidget(clear_btn)
        
        btn_layout.addStretch()
        
        layout.addLayout(btn_layout)
        layout.addStretch()
        
        return widget
    
    # ========== TAB: STATISTICS ==========
    
    def _create_stats_tab(self) -> QWidget:
        widget = QWidget()
        layout = QVBoxLayout(widget)
        
        # Summary stats
        summary_group = QGroupBox("Summary Statistics")
        summary_layout = QVBoxLayout(summary_group)
        
        self.stats_summary = QLabel("")
        self.stats_summary.setFont(QFont("Monospace", 10))
        self.stats_summary.setWordWrap(True)
        summary_layout.addWidget(self.stats_summary)
        
        layout.addWidget(summary_group)
        
        # By category
        category_group = QGroupBox("Exploits by Category")
        category_layout = QVBoxLayout(category_group)
        
        self.stats_category = QPlainTextEdit()
        self.stats_category.setReadOnly(True)
        self.stats_category.setFont(QFont("Monospace", 10))
        category_layout.addWidget(self.stats_category)
        
        layout.addWidget(category_group)
        
        # By status
        status_group = QGroupBox("Exploits by Status")
        status_layout = QVBoxLayout(status_group)
        
        self.stats_status = QPlainTextEdit()
        self.stats_status.setReadOnly(True)
        self.stats_status.setFont(QFont("Monospace", 10))
        status_layout.addWidget(self.stats_status)
        
        layout.addWidget(status_group)
        
        # Most successful
        success_group = QGroupBox("Top Performing Exploits")
        success_layout = QVBoxLayout(success_group)
        
        self.stats_successful = QPlainTextEdit()
        self.stats_successful.setReadOnly(True)
        self.stats_successful.setFont(QFont("Monospace", 10))
        success_layout.addWidget(self.stats_successful)
        
        refresh_btn = QPushButton("ðŸ”„ Refresh Statistics")
        refresh_btn.clicked.connect(self._refresh_statistics)
        success_layout.addWidget(refresh_btn)
        
        layout.addWidget(success_group)
        
        return widget
    
    # ========== TAB: COLLECTIONS ==========
    
    def _create_collections_tab(self) -> QWidget:
        widget = QWidget()
        layout = QVBoxLayout(widget)
        
        # Create collection
        create_group = QGroupBox("Create Collection")
        create_layout = QHBoxLayout(create_group)
        
        self.collection_name = QLineEdit()
        self.collection_name.setPlaceholderText("Collection name...")
        create_layout.addWidget(self.collection_name)
        
        create_btn = QPushButton("âž• Create")
        create_btn.clicked.connect(self._create_collection)
        create_layout.addWidget(create_btn)
        
        layout.addWidget(create_group)
        
        # Collections list
        self.collections_list = QTreeWidget()
        self.collections_list.setHeaderLabels(["Collection", "Exploits"])
        layout.addWidget(self.collections_list)
        
        # Add to collection
        add_group = QGroupBox("Add Exploit to Collection")
        add_layout = QHBoxLayout(add_group)
        
        self.collection_select = QComboBox()
        add_layout.addWidget(self.collection_select)
        
        add_collection_btn = QPushButton("âž• Add Selected Exploit")
        add_collection_btn.clicked.connect(self._add_to_collection)
        add_layout.addWidget(add_collection_btn)
        
        layout.addWidget(add_group)
        
        refresh_collections_btn = QPushButton("ðŸ”„ Refresh Collections")
        refresh_collections_btn.clicked.connect(self._refresh_collections)
        layout.addWidget(refresh_collections_btn)
        
        return widget
    
    # ========== TAB: EXECUTION HISTORY ==========
    
    def _create_history_tab(self) -> QWidget:
        widget = QWidget()
        layout = QVBoxLayout(widget)
        
        info_layout = QHBoxLayout()
        info_layout.addWidget(QLabel("ðŸ“‹ Showing execution history for selected exploit"))
        info_layout.addStretch()
        
        layout.addLayout(info_layout)
        
        # History table
        self.history_table = QTableWidget()
        self.history_table.setColumnCount(6)
        self.history_table.setHorizontalHeaderLabels([
            "Timestamp", "Target URL", "Result", "Response Preview", 
            "Error", "Details"
        ])
        self.history_table.horizontalHeader().setSectionResizeMode(QHeaderView.ResizeMode.Stretch)
        layout.addWidget(self.history_table)
        
        return widget
    
    # ========== HELPER METHODS ==========
    
    def refresh_all(self):
        """Refresh all views"""
        self._refresh_exploits_list()
        self._refresh_statistics()
        self._refresh_collections()
    
    def _refresh_exploits_list(self):
        """Reload exploits from database and update table"""
        self.exploits_table.setRowCount(0)
        
        # Update category filter
        categories = self.tome.get_categories()
        current = self.category_filter.currentText()
        self.category_filter.blockSignals(True)
        self.category_filter.clear()
        self.category_filter.addItem("All Categories")
        self.category_filter.addItems(categories)
        self.category_filter.setCurrentText(current if current != "" else "All Categories")
        self.category_filter.blockSignals(False)
        
        # Get all exploits
        exploits = self.tome.get_all_exploits()
        
        for idx, exploit in enumerate(exploits):
            self.exploits_table.insertRow(idx)
            
            # Name
            self.exploits_table.setItem(idx, 0, QTableWidgetItem(exploit.name))
            
            # Category
            self.exploits_table.setItem(idx, 1, QTableWidgetItem(exploit.category))
            
            # Target (truncated)
            target = exploit.target[:50] + "..." if len(exploit.target) > 50 else exploit.target
            self.exploits_table.setItem(idx, 2, QTableWidgetItem(target))
            
            # Success rate
            rate = exploit.get_success_rate()
            rate_item = QTableWidgetItem(f"{rate:.0f}%")
            if rate >= 80:
                rate_item.setBackground(QColor("#2d5d2d"))
            elif rate >= 50:
                rate_item.setBackground(QColor("#5d4d2d"))
            else:
                rate_item.setBackground(QColor("#5d2d2d"))
            self.exploits_table.setItem(idx, 3, rate_item)
            
            # Status
            status_item = QTableWidgetItem(exploit.status)
            if exploit.status == "active":
                status_item.setBackground(QColor("#2d4d5d"))
            elif exploit.status == "archived":
                status_item.setBackground(QColor("#3d3d3d"))
            self.exploits_table.setItem(idx, 4, status_item)
            
            # Created
            created = exploit.created_at[:10] if exploit.created_at else "Unknown"
            self.exploits_table.setItem(idx, 5, QTableWidgetItem(created))
            
            # Store ID for reference
            self.exploits_table.item(idx, 0).setData(Qt.ItemDataRole.UserRole, exploit.id)
    
    def _filter_exploits(self):
        """Apply filters to exploit list"""
        search = self.search_input.text().lower()
        status = self.status_filter.currentText()
        category = self.category_filter.currentText()
        
        for row in range(self.exploits_table.rowCount()):
            show = True
            
            # Status filter
            if status != "All Status":
                status_item = self.exploits_table.item(row, 4)
                if status_item.text() != status:
                    show = False
            
            # Category filter
            if show and category != "All Categories":
                category_item = self.exploits_table.item(row, 1)
                if category_item.text() != category:
                    show = False
            
            # Search filter
            if show and search:
                name = self.exploits_table.item(row, 0).text().lower()
                target = self.exploits_table.item(row, 2).text().lower()
                if search not in name and search not in target:
                    show = False
            
            self.exploits_table.setRowHidden(row, not show)
    
    def _on_exploit_selected(self, item):
        """Handle exploit selection"""
        row = item.row()
        exploit_id = self.exploits_table.item(row, 0).data(Qt.ItemDataRole.UserRole)
        self.current_exploit_id = exploit_id
        
        exploit = self.tome.get_exploit(exploit_id)
        if not exploit:
            return
        
        # Update info panel
        info_text = f"""
<b>{exploit.name}</b>
Category: {exploit.category}
Target: {exploit.target}

Success Rate: {exploit.get_success_rate():.1f}%
  Success: {exploit.success_count}
  Failures: {exploit.fail_count}

Status: {exploit.status}
Created: {exploit.created_at}
Last Used: {exploit.last_used or 'Never'}

Notes: {exploit.notes}

CVEs: {', '.join(exploit.cve_ids) if exploit.cve_ids else 'N/A'}
Tags: {', '.join(exploit.tags) if exploit.tags else 'N/A'}
"""
        self.exploit_info.setText(info_text)
        
        # Update code display
        self.exploit_code_display.setPlainText(exploit.payload)
        
        # Load history
        self._load_exploit_history(exploit_id)
    
    def _load_exploit_history(self, exploit_id: str):
        """Load execution history for exploit"""
        self.history_table.setRowCount(0)
        history = self.tome.get_execution_history(exploit_id)
        
        for idx, entry in enumerate(history):
            self.history_table.insertRow(idx)
            
            self.history_table.setItem(idx, 0, QTableWidgetItem(entry['timestamp'][-19:]))
            self.history_table.setItem(idx, 1, QTableWidgetItem(entry['target_url'][:50]))
            
            result_item = QTableWidgetItem(entry['result'])
            if entry['result'] == 'success':
                result_item.setBackground(QColor("#2d5d2d"))
            else:
                result_item.setBackground(QColor("#5d2d2d"))
            self.history_table.setItem(idx, 2, result_item)
            
            response_preview = (entry['response'][:50] + "...") if entry['response'] else ""
            self.history_table.setItem(idx, 3, QTableWidgetItem(response_preview))
            
            error_preview = (entry['error'][:50] + "...") if entry['error'] else ""
            self.history_table.setItem(idx, 4, QTableWidgetItem(error_preview))
            
            details = f"Response: {len(entry['response'])} bytes"
            self.history_table.setItem(idx, 5, QTableWidgetItem(details))
    
    def _save_exploit(self):
        """Save exploit to database"""
        name = self.edit_name.text().strip()
        category = self.edit_category.text().strip()
        target = self.edit_target.text().strip()
        payload = self.edit_payload.toPlainText().strip()
        notes = self.edit_notes.toPlainText().strip()
        cve_str = self.edit_cve.text().strip()
        refs_str = self.edit_reference_links.toPlainText().strip()
        tags_str = self.edit_tags.text().strip()
        
        if not all([name, category, target, payload]):
            QMessageBox.warning(self, "Validation Error", "Please fill in all required fields")
            return
        
        # Parse tags, CVEs, references
        cve_ids = [c.strip() for c in cve_str.split(',') if c.strip()]
        references = [r.strip() for r in refs_str.split('\n') if r.strip()]
        tags = [t.strip() for t in tags_str.split(',') if t.strip()]
        
        # Generate ID
        exploit_id = f"{category.lower().replace(' ', '_')}_{int(datetime.now().timestamp())}"
        
        exploit = ExploitEntry(
            id=exploit_id,
            name=name,
            category=category,
            target=target,
            payload=payload,
            notes=notes,
            cve_ids=cve_ids,
            references=references,
            tags=tags,
            created_at=datetime.now().isoformat()
        )
        
        if self.tome.add_exploit(exploit):
            QMessageBox.information(self, "Success", "Exploit saved to Tome!")
            self._clear_edit_form()
            self._refresh_exploits_list()
        else:
            QMessageBox.critical(self, "Error", "Failed to save exploit")
    
    def _clear_edit_form(self):
        """Clear the edit form"""
        self.edit_name.clear()
        self.edit_category.clear()
        self.edit_target.clear()
        self.edit_payload.clear()
        self.edit_notes.clear()
        self.edit_cve.clear()
        self.edit_reference_links.clear()
        self.edit_tags.clear()
    
    def _delete_selected_exploit(self):
        """Delete selected exploit"""
        if not self.current_exploit_id:
            QMessageBox.warning(self, "Warning", "No exploit selected")
            return
        
        reply = QMessageBox.question(
            self, "Confirm Delete",
            "Are you sure you want to delete this exploit?\nThis cannot be undone.",
            QMessageBox.StandardButton.Yes | QMessageBox.StandardButton.No
        )
        
        if reply == QMessageBox.StandardButton.Yes:
            if self.tome.delete_exploit(self.current_exploit_id):
                QMessageBox.information(self, "Success", "Exploit deleted")
                self._refresh_exploits_list()
            else:
                QMessageBox.critical(self, "Error", "Failed to delete exploit")
    
    def _edit_selected_exploit(self):
        """Load selected exploit into edit form"""
        if not self.current_exploit_id:
            QMessageBox.warning(self, "Warning", "No exploit selected")
            return
        
        exploit = self.tome.get_exploit(self.current_exploit_id)
        if not exploit:
            return
        
        self.edit_name.setText(exploit.name)
        self.edit_category.setText(exploit.category)
        self.edit_target.setText(exploit.target)
        self.edit_payload.setPlainText(exploit.payload)
        self.edit_notes.setPlainText(exploit.notes)
        self.edit_cve.setText(', '.join(exploit.cve_ids))
        self.edit_reference_links.setPlainText('\n'.join(exploit.reference_links))
        self.edit_tags.setText(', '.join(exploit.tags))
        
        QMessageBox.information(self, "Edit Mode", 
            "Edit the exploit and click 'Save Exploit' to update it.")
    
    def _clone_exploit(self):
        """Clone selected exploit"""
        if not self.current_exploit_id:
            QMessageBox.warning(self, "Warning", "No exploit selected")
            return
        
        exploit = self.tome.get_exploit(self.current_exploit_id)
        if not exploit:
            return
        
        # Create cloned version
        new_id = f"{exploit.id}_clone_{int(datetime.now().timestamp())}"
        cloned = ExploitEntry(
            id=new_id,
            name=f"{exploit.name} (Clone)",
            category=exploit.category,
            target=exploit.target,
            payload=exploit.payload,
            notes=exploit.notes,
            tags=exploit.tags,
            cve_ids=exploit.cve_ids,
            reference_links=exploit.reference_links,
            created_at=datetime.now().isoformat()
        )
        
        if self.tome.add_exploit(cloned):
            QMessageBox.information(self, "Success", "Exploit cloned!")
            self._refresh_exploits_list()
        else:
            QMessageBox.critical(self, "Error", "Failed to clone exploit")
    
    def _archive_exploit(self):
        """Archive selected exploit"""
        if not self.current_exploit_id:
            QMessageBox.warning(self, "Warning", "No exploit selected")
            return
        
        exploit = self.tome.get_exploit(self.current_exploit_id)
        new_status = "active" if exploit.status == "archived" else "archived"
        
        if self.tome.update_exploit(self.current_exploit_id, status=new_status):
            QMessageBox.information(self, "Success", f"Exploit {new_status}")
            self._refresh_exploits_list()
    
    def _export_single_exploit(self):
        """Export single exploit to JSON"""
        if not self.current_exploit_id:
            QMessageBox.warning(self, "Warning", "No exploit selected")
            return
        
        filename, _ = QFileDialog.getSaveFileName(
            self, "Export Exploit", "", "JSON Files (*.json)"
        )
        
        if filename:
            exploit = self.tome.get_exploit(self.current_exploit_id)
            data = {
                'exported_at': datetime.now().isoformat(),
                'exploit': asdict(exploit)
            }
            
            with open(filename, 'w') as f:
                json.dump(data, f, indent=2)
            
            QMessageBox.information(self, "Success", f"Exported to {filename}")
    
    def _export_all_exploits(self):
        """Export all exploits to JSON"""
        filename, _ = QFileDialog.getSaveFileName(
            self, "Export All Exploits", "exploits_backup.json", "JSON Files (*.json)"
        )
        
        if filename:
            if self.tome.export_to_json(filename):
                QMessageBox.information(self, "Success", f"Exported all exploits to {filename}")
            else:
                QMessageBox.critical(self, "Error", "Failed to export exploits")
    
    def _import_exploits(self):
        """Import exploits from JSON"""
        filename, _ = QFileDialog.getOpenFileName(
            self, "Import Exploits", "", "JSON Files (*.json)"
        )
        
        if filename:
            count = self.tome.import_from_json(filename)
            QMessageBox.information(self, "Success", f"Imported {count} exploits")
            self._refresh_exploits_list()
    
    def _refresh_statistics(self):
        """Update statistics views"""
        stats = self.tome.get_statistics()
        
        # Summary
        summary_text = f"""
Total Exploits: {stats.get('total_exploits', 0)}
Overall Success Rate: {stats.get('overall_success_rate', 0):.1f}%

Status Distribution:
"""
        for status, count in stats.get('by_status', {}).items():
            summary_text += f"  {status}: {count}\n"
        
        self.stats_summary.setText(summary_text)
        
        # By category
        category_text = ""
        for category, count in stats.get('by_category', {}).items():
            category_text += f"{category}: {count}\n"
        self.stats_category.setPlainText(category_text if category_text else "No categories yet")
        
        # By status
        status_text = ""
        for status, count in stats.get('by_status', {}).items():
            status_text += f"{status}: {count}\n"
        self.stats_status.setPlainText(status_text if status_text else "No exploits yet")
        
        # Most successful
        success_text = ""
        for exploit in stats.get('most_successful', []):
            success_text += f"{exploit['name']}: {exploit['count']} successes\n"
        self.stats_successful.setPlainText(success_text if success_text else "No executions yet")
    
    def _create_collection(self):
        """Create new collection"""
        name = self.collection_name.text().strip()
        if not name:
            QMessageBox.warning(self, "Warning", "Please enter a collection name")
            return
        
        if self.tome.create_collection(name):
            QMessageBox.information(self, "Success", "Collection created")
            self.collection_name.clear()
            self._refresh_collections()
        else:
            QMessageBox.critical(self, "Error", "Failed to create collection")
    
    def _refresh_collections(self):
        """Update collections list"""
        self.collections_list.clear()
        self.collection_select.clear()
        
        collections = self.tome.get_collections()
        
        for coll in collections:
            exploits = self.tome.get_collection_exploits(coll['name'])
            item = QTreeWidgetItem([coll['name'], str(len(exploits))])
            self.collections_list.addTopLevelItem(item)
            
            for exploit in exploits:
                QTreeWidgetItem(item, [exploit.name])
            
            self.collection_select.addItem(coll['name'])
    
    def _add_to_collection(self):
        """Add selected exploit to collection"""
        if not self.current_exploit_id:
            QMessageBox.warning(self, "Warning", "No exploit selected")
            return
        
        collection_name = self.collection_select.currentText()
        if not collection_name:
            QMessageBox.warning(self, "Warning", "No collection selected")
            return
        
        if self.tome.add_to_collection(collection_name, self.current_exploit_id):
            QMessageBox.information(self, "Success", "Exploit added to collection")
            self._refresh_collections()
        else:
            QMessageBox.critical(self, "Error", "Failed to add to collection")


def create_exploit_tome_tab() -> QWidget:
    """Factory function to create the exploit tome tab"""
    return ExploitTomeTab()
