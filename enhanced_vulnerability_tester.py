"""
Enhanced Vulnerability Tester - Compliance-Ready
Implements: Response capture, baseline comparison, deterministic tests
"""

import logging
import json
import time
import threading
import hashlib
from typing import Dict, List, Optional, Tuple
from dataclasses import dataclass, asdict
from datetime import datetime
from urllib.parse import urlparse, urljoin
import requests
from requests.adapters import HTTPAdapter
from urllib3.util.retry import Retry

logger = logging.getLogger("EnhancedVulnerabilityTester")


@dataclass
class ResponseCapture:
    """Complete evidence from a test"""
    endpoint_path: str
    endpoint_full_url: str
    method: str
    payload_sent: str
    status_code: int
    response_length: int
    response_excerpt: str  # First 500 chars of response
    response_hash: str  # SHA256 of full response
    headers_sent: Dict
    headers_received: Dict
    timestamp: float
    

@dataclass
class BaselineComparison:
    """Comparison between benign and attack payloads"""
    benign_response_hash: str
    benign_status_code: int
    benign_length: int
    attack_response_hash: str
    attack_status_code: int
    attack_length: int
    hash_differs: bool  # Did response actually change?
    status_differs: bool
    length_differs: bool
    delta_bytes: int  # Absolute difference


@dataclass
class DeterministicTestResult:
    """Evidence-based test result"""
    test_id: str
    test_name: str
    test_type: str
    severity: str
    vulnerable: bool  # Only True if PROVEN
    confidence: float  # 0.0-1.0, based on actual evidence
    evidence_type: str  # 'sql_error', 'payload_reflected', 'status_change', 'baseline_delta'
    evidence_excerpt: str  # Actual proof
    baseline_comparison: Optional[BaselineComparison]
    capture_benign: ResponseCapture
    capture_attack: ResponseCapture
    payload_used: str
    endpoint_tested: str
    timestamp: float


class DeterministicValidators:
    """True/false vulnerability detection based on actual evidence"""
    
    @staticmethod
    def detect_sql_error(response: ResponseCapture) -> Tuple[bool, str, float]:
        """
        Detect SQL injection via database-specific error signatures.
        Returns: (is_vulnerable, evidence, confidence)
        
        TRUE POSITIVE only if actual database error found.
        """
        excerpt = response.response_excerpt.lower()
        
        # Database-specific error signatures (EXACT matches)
        sql_errors = [
            ('SQLSTATE', 'PostgreSQL SQLSTATE error'),
            ('ORA-', 'Oracle error'),
            ('MySQL Error', 'MySQL error'),
            ('MSSQL Error', 'SQL Server error'),
            ('near \'', 'SQLite syntax error'),
            ('Parse error', 'SQL parse error'),
            ('Syntax error', 'SQL syntax error (specific)'),
            ('you have an error in your sql syntax', 'MySQL exact error'),
        ]
        
        for error_sig, error_type in sql_errors:
            if error_sig.lower() in excerpt:
                # Verify it's not in a comment or benign context
                if 'mysql' in excerpt or 'postgres' in excerpt or 'oracle' in excerpt:
                    return True, f"Database error detected: {error_type}", 0.95
        
        # Additional check: deterministic error message patterns
        error_patterns = [
            'database error',
            'sql exception',
            'constraint violation',
        ]
        
        for pattern in error_patterns:
            if pattern in excerpt:
                # Verify endpoint actually processes SQL (check response length)
                if response.response_length > 100:  # Some content returned
                    return True, f"SQL error signature: {pattern}", 0.85
        
        return False, "No SQL error detected", 0.0

    @staticmethod
    def detect_xss_reflected(response: ResponseCapture, payload: str) -> Tuple[bool, str, float]:
        """
        Detect XSS by checking if payload appears unescaped in response.
        Returns: (is_vulnerable, evidence, confidence)
        """
        excerpt = response.response_excerpt
        excerpt_lower = excerpt.lower()
        payload_lower = payload.lower()
        
        # Check if payload appears in response at all
        if payload_lower not in excerpt_lower:
            return False, "Payload not reflected in response", 0.0
        
        # Find the exact reflection
        start_idx = excerpt_lower.find(payload_lower)
        if start_idx == -1:
            return False, "Payload not found", 0.0
        
        reflection = excerpt[start_idx:start_idx + len(payload) + 50]
        
        # Check if payload is HTML-encoded (escaped)
        encoded_checks = [
            ('&lt;', '&gt;'),  # HTML-encoded < >
            ('&#', ';'),  # HTML entity encoded
            ('%3C', '%3E'),  # URL encoded < >
        ]
        
        for start_enc, end_enc in encoded_checks:
            if start_enc in reflection or end_enc in reflection:
                # Payload was escaped - NOT vulnerable
                return False, f"Payload was HTML-encoded: {reflection[:100]}", 0.0
        
        # Payload is unescaped - check if in executable context
        before = excerpt[max(0, start_idx-20):start_idx]
        after = excerpt[start_idx + len(payload):start_idx + len(payload) + 20]
        
        dangerous_contexts = [
            ('href=', 'href attribute'),
            ('src=', 'src attribute'),
            ('<script', 'script tag'),
            ('onload=', 'event handler'),
            ('onerror=', 'event handler'),
            ('onclick=', 'event handler'),
        ]
        
        for context, context_type in dangerous_contexts:
            if context in before.lower() or context in after.lower():
                return True, f"Unescaped XSS in {context_type}: {reflection[:100]}", 0.95
        
        # Unescaped but in HTML content (still XSS)
        if '<' not in reflection or '>' not in reflection:
            # Plain text reflection (unlikely to be XSS)
            return False, "Payload reflected but in text context", 0.2
        
        return True, f"Unescaped payload reflected in HTML: {reflection[:100]}", 0.85

    @staticmethod
    def detect_auth_bypass(response_auth: ResponseCapture, baseline_auth: ResponseCapture,
                          bypass_type: str = 'default_creds') -> Tuple[bool, str, float]:
        """
        Detect authentication bypass by comparing authenticated vs. unauthenticated responses.
        Returns: (is_vulnerable, evidence, confidence)
        """
        
        # Success indicators: specific keywords that appear ONLY in authenticated responses
        success_indicators = [
            'dashboard',
            'welcome',
            'logout',
            'user profile',
            'settings',
            'admin panel',
        ]
        
        # Response must contain success indicator AND status must be 200
        if response_auth.status_code != 200:
            return False, f"Auth attempt returned {response_auth.status_code}, not 200", 0.0
        
        # Count success indicators in auth response
        excerpt_lower = response_auth.response_excerpt.lower()
        found_indicators = [ind for ind in success_indicators if ind in excerpt_lower]
        
        if len(found_indicators) < 1:
            return False, "No success indicators found in response", 0.0
        
        # Verify that baseline (failed auth) does NOT contain these
        baseline_lower = baseline_auth.response_excerpt.lower()
        baseline_indicators = [ind for ind in success_indicators if ind in baseline_lower]
        
        # If baseline also has success indicators, responses are identical (no bypass)
        if len(baseline_indicators) >= len(found_indicators):
            return False, "Baseline response identical to auth response (no bypass)", 0.0
        
        # Responses differ - check length delta
        length_delta = abs(response_auth.response_length - baseline_auth.response_length)
        
        if length_delta < 20:
            # Minimal difference - could be false positive
            return False, f"Response length delta only {length_delta} bytes (minimal difference)", 0.3
        
        return True, f"Auth bypass detected: Found indicators {found_indicators}, " \
                    f"baseline missing them. Delta: {length_delta} bytes", 0.9

    @staticmethod
    def detect_path_traversal(response: ResponseCapture, payload: str, 
                             expected_file_content: List[str]) -> Tuple[bool, str, float]:
        """
        Detect path traversal by checking for file content signatures.
        Returns: (is_vulnerable, evidence, confidence)
        """
        excerpt = response.response_excerpt.lower()
        
        # For /etc/passwd, check for known user entries
        if 'passwd' in payload.lower():
            passwd_indicators = ['root:', 'bin:', 'daemon:', 'nobody:', 'systemd-']
            found = [ind for ind in passwd_indicators if ind in excerpt]
            
            if len(found) >= 2:  # Found multiple passwd entries
                evidence = f"Found {len(found)} passwd file entries: {', '.join(found[:3])}"
                return True, evidence, 0.95
        
        # For Windows win.ini
        if 'win.ini' in payload.lower() or 'windows\\' in payload.lower():
            windows_indicators = ['[fonts]', '[extensions]', 'system32', '[drivers]']
            found = [ind for ind in windows_indicators if ind in excerpt]
            
            if len(found) >= 1:
                evidence = f"Found Windows ini content: {found[0]}"
                return True, evidence, 0.9
        
        # Generic: check for file content in response
        if len(expected_file_content) > 0:
            found = [cont for cont in expected_file_content if cont in excerpt]
            if len(found) >= 1:
                return True, f"Found file content: {found[0]}", 0.85
        
        return False, "No file content detected", 0.0

    @staticmethod
    def detect_response_delta(benign: ResponseCapture, attack: ResponseCapture,
                             min_delta: int = 100) -> Tuple[bool, str, float]:
        """
        Detect vulnerability by significant response delta (baseline comparison).
        Fallback for tests where specific error signatures not available.
        Returns: (is_vulnerable, evidence, confidence)
        """
        
        # Status code change is significant
        if benign.status_code != attack.status_code:
            # Status changes from 200 to 500 indicate crash (likely vuln)
            if attack.status_code == 500:
                return True, f"Status changed {benign.status_code} -> {attack.status_code} (server error)", 0.75
            # Status change to 403 might indicate WAF or access control change
            if attack.status_code == 403 and benign.status_code != 403:
                return True, f"Status changed {benign.status_code} -> 403 (access change)", 0.65
        
        # Response length delta
        delta = abs(attack.response_length - benign.response_length)
        if delta < min_delta:
            return False, f"Response delta only {delta} bytes (< {min_delta} threshold)", 0.0
        
        # Hash differs significantly
        if benign.response_hash != attack.response_hash:
            pct_change = (delta / max(benign.response_length, 1)) * 100
            if pct_change > 5:  # >5% content change
                return True, f"Response changed {pct_change:.1f}% ({delta} bytes)", 0.7
        
        return False, f"Insufficient delta (status same, {delta} byte change)", 0.1


class EnhancedVulnerabilityTester:
    """Compliance-ready vulnerability tester with proper evidence capture"""
    
    def __init__(self, timeout: int = 10, verify_ssl: bool = False):
        self.timeout = timeout
        self.verify_ssl = verify_ssl
        self.session = self._create_session()
        self.test_results: List[DeterministicTestResult] = []
        
    def _create_session(self) -> requests.Session:
        """Create session with retries"""
        session = requests.Session()
        retry_strategy = Retry(total=2, backoff_factor=0.5)
        adapter = HTTPAdapter(max_retries=retry_strategy)
        session.mount("http://", adapter)
        session.mount("https://", adapter)
        return session
    
    def _hash_response(self, content: str) -> str:
        """SHA256 hash of response content"""
        return hashlib.sha256(content.encode()).hexdigest()
    
    def _capture_response(self, url: str, method: str = 'GET', 
                         payload: Optional[str] = None,
                         headers: Optional[Dict] = None) -> ResponseCapture:
        """Execute request and capture full evidence"""
        
        parsed = urlparse(url)
        endpoint_path = parsed.path or '/'
        if parsed.query:
            endpoint_path += f"?{parsed.query}"
        
        try:
            if method == 'GET':
                resp = self.session.get(url, headers=headers, timeout=self.timeout, 
                                       verify=self.verify_ssl)
            elif method == 'POST':
                resp = self.session.post(url, data=payload, headers=headers, 
                                        timeout=self.timeout, verify=self.verify_ssl)
            else:
                resp = self.session.request(method, url, headers=headers, 
                                           timeout=self.timeout, verify=self.verify_ssl)
            
            excerpt = resp.text[:500] if resp.text else ""
            response_hash = self._hash_response(resp.text)
            
            return ResponseCapture(
                endpoint_path=endpoint_path,
                endpoint_full_url=url,
                method=method,
                payload_sent=payload or "",
                status_code=resp.status_code,
                response_length=len(resp.content),
                response_excerpt=excerpt,
                response_hash=response_hash,
                headers_sent=headers or {},
                headers_received=dict(resp.headers),
                timestamp=time.time()
            )
        except Exception as e:
            # Return error response
            return ResponseCapture(
                endpoint_path=endpoint_path,
                endpoint_full_url=url,
                method=method,
                payload_sent=payload or "",
                status_code=0,
                response_length=0,
                response_excerpt=f"ERROR: {str(e)}",
                response_hash="",
                headers_sent=headers or {},
                headers_received={},
                timestamp=time.time()
            )
    
    def test_sql_injection(self, base_url: str, param_name: str = 'id') -> DeterministicTestResult:
        """
        Test SQL injection with baseline comparison and deterministic detection.
        """
        test_id = f"sqli_{hashlib.md5(base_url.encode()).hexdigest()[:8]}"
        
        # Build URLs
        benign_payload = "1"
        attack_payload = "' OR '1'='1'--"
        
        benign_url = f"{base_url}?{param_name}={benign_payload}"
        attack_url = f"{base_url}?{param_name}={attack_payload}"
        
        # Capture both responses
        capture_benign = self._capture_response(benign_url, method='GET')
        capture_attack = self._capture_response(attack_url, method='GET')
        
        # Test 1: SQL error detection
        is_vulnerable, evidence, confidence = DeterministicValidators.detect_sql_error(capture_attack)
        
        if is_vulnerable:
            baseline_comp = BaselineComparison(
                benign_response_hash=capture_benign.response_hash,
                benign_status_code=capture_benign.status_code,
                benign_length=capture_benign.response_length,
                attack_response_hash=capture_attack.response_hash,
                attack_status_code=capture_attack.status_code,
                attack_length=capture_attack.response_length,
                hash_differs=capture_benign.response_hash != capture_attack.response_hash,
                status_differs=capture_benign.status_code != capture_attack.status_code,
                length_differs=abs(capture_benign.response_length - capture_attack.response_length) > 20,
                delta_bytes=abs(capture_benign.response_length - capture_attack.response_length)
            )
            
            result = DeterministicTestResult(
                test_id=test_id,
                test_name="SQL Injection",
                test_type="injection",
                severity="Critical",
                vulnerable=True,
                confidence=confidence,
                evidence_type="sql_error",
                evidence_excerpt=evidence,
                baseline_comparison=baseline_comp,
                capture_benign=capture_benign,
                capture_attack=capture_attack,
                payload_used=attack_payload,
                endpoint_tested=benign_url,
                timestamp=time.time()
            )
            self.test_results.append(result)
            return result
        
        # Test 2: Baseline delta detection (fallback)
        is_vulnerable, evidence, confidence = DeterministicValidators.detect_response_delta(
            capture_benign, capture_attack, min_delta=50
        )
        
        baseline_comp = BaselineComparison(
            benign_response_hash=capture_benign.response_hash,
            benign_status_code=capture_benign.status_code,
            benign_length=capture_benign.response_length,
            attack_response_hash=capture_attack.response_hash,
            attack_status_code=capture_attack.status_code,
            attack_length=capture_attack.response_length,
            hash_differs=capture_benign.response_hash != capture_attack.response_hash,
            status_differs=capture_benign.status_code != capture_attack.status_code,
            length_differs=abs(capture_benign.response_length - capture_attack.response_length) > 20,
            delta_bytes=abs(capture_benign.response_length - capture_attack.response_length)
        )
        
        result = DeterministicTestResult(
            test_id=test_id,
            test_name="SQL Injection",
            test_type="injection",
            severity="Critical",
            vulnerable=is_vulnerable,
            confidence=confidence,
            evidence_type="baseline_delta",
            evidence_excerpt=evidence,
            baseline_comparison=baseline_comp,
            capture_benign=capture_benign,
            capture_attack=capture_attack,
            payload_used=attack_payload,
            endpoint_tested=benign_url,
            timestamp=time.time()
        )
        self.test_results.append(result)
        return result
    
    def test_xss(self, base_url: str, param_name: str = 'q') -> DeterministicTestResult:
        """Test XSS with reflection detection"""
        test_id = f"xss_{hashlib.md5(base_url.encode()).hexdigest()[:8]}"
        
        benign_payload = "search"
        attack_payload = '<img src=x onerror="alert(1)">'
        
        benign_url = f"{base_url}?{param_name}={benign_payload}"
        attack_url = f"{base_url}?{param_name}={attack_payload}"
        
        capture_benign = self._capture_response(benign_url, method='GET')
        capture_attack = self._capture_response(attack_url, method='GET')
        
        # XSS detection
        is_vulnerable, evidence, confidence = DeterministicValidators.detect_xss_reflected(
            capture_attack, attack_payload
        )
        
        baseline_comp = BaselineComparison(
            benign_response_hash=capture_benign.response_hash,
            benign_status_code=capture_benign.status_code,
            benign_length=capture_benign.response_length,
            attack_response_hash=capture_attack.response_hash,
            attack_status_code=capture_attack.status_code,
            attack_length=capture_attack.response_length,
            hash_differs=capture_benign.response_hash != capture_attack.response_hash,
            status_differs=capture_benign.status_code != capture_attack.status_code,
            length_differs=abs(capture_benign.response_length - capture_attack.response_length) > 20,
            delta_bytes=abs(capture_benign.response_length - capture_attack.response_length)
        )
        
        result = DeterministicTestResult(
            test_id=test_id,
            test_name="Cross-Site Scripting (XSS)",
            test_type="injection",
            severity="High",
            vulnerable=is_vulnerable,
            confidence=confidence,
            evidence_type="payload_reflected",
            evidence_excerpt=evidence,
            baseline_comparison=baseline_comp,
            capture_benign=capture_benign,
            capture_attack=capture_attack,
            payload_used=attack_payload,
            endpoint_tested=benign_url,
            timestamp=time.time()
        )
        self.test_results.append(result)
        return result
    
    def test_path_traversal(self, base_url: str, param_name: str = 'file') -> DeterministicTestResult:
        """Test path traversal with file content detection"""
        test_id = f"lfi_{hashlib.md5(base_url.encode()).hexdigest()[:8]}"
        
        benign_payload = "readme.txt"
        attack_payload = "../../../../etc/passwd"
        
        benign_url = f"{base_url}?{param_name}={benign_payload}"
        attack_url = f"{base_url}?{param_name}={attack_payload}"
        
        capture_benign = self._capture_response(benign_url, method='GET')
        capture_attack = self._capture_response(attack_url, method='GET')
        
        # Path traversal detection
        is_vulnerable, evidence, confidence = DeterministicValidators.detect_path_traversal(
            capture_attack, attack_payload, []
        )
        
        baseline_comp = BaselineComparison(
            benign_response_hash=capture_benign.response_hash,
            benign_status_code=capture_benign.status_code,
            benign_length=capture_benign.response_length,
            attack_response_hash=capture_attack.response_hash,
            attack_status_code=capture_attack.status_code,
            attack_length=capture_attack.response_length,
            hash_differs=capture_benign.response_hash != capture_attack.response_hash,
            status_differs=capture_benign.status_code != capture_attack.status_code,
            length_differs=abs(capture_benign.response_length - capture_attack.response_length) > 20,
            delta_bytes=abs(capture_benign.response_length - capture_attack.response_length)
        )
        
        result = DeterministicTestResult(
            test_id=test_id,
            test_name="Path Traversal (LFI)",
            test_type="path_traversal",
            severity="Critical",
            vulnerable=is_vulnerable,
            confidence=confidence,
            evidence_type="file_content",
            evidence_excerpt=evidence,
            baseline_comparison=baseline_comp,
            capture_benign=capture_benign,
            capture_attack=capture_attack,
            payload_used=attack_payload,
            endpoint_tested=benign_url,
            timestamp=time.time()
        )
        self.test_results.append(result)
        return result
    
    def export_results_json(self, filename: str = None) -> str:
        """Export results as compliance-ready JSON"""
        if not filename:
            timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
            filename = f"compliance_test_report_{timestamp}.json"
        
        # Convert dataclass instances to dicts
        results_dict = []
        for result in self.test_results:
            result_data = asdict(result)
            # Convert nested dataclasses
            if result.baseline_comparison:
                result_data['baseline_comparison'] = asdict(result.baseline_comparison)
            result_data['capture_benign'] = asdict(result.capture_benign)
            result_data['capture_attack'] = asdict(result.capture_attack)
            results_dict.append(result_data)
        
        report = {
            'report_type': 'Compliance-Ready Vulnerability Assessment',
            'generated': datetime.now().isoformat(),
            'total_tests': len(self.test_results),
            'vulnerabilities_proven': sum(1 for r in self.test_results if r.vulnerable),
            'results': results_dict
        }
        
        with open(filename, 'w') as f:
            json.dump(report, f, indent=2, default=str)
        
        logger.info(f"Compliance report exported to {filename}")
        return filename
    
    def export_results_markdown(self, filename: str = None) -> str:
        """Export results as human-readable markdown"""
        if not filename:
            timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
            filename = f"compliance_test_report_{timestamp}.md"
        
        with open(filename, 'w') as f:
            f.write("# Compliance-Ready Vulnerability Test Report\n\n")
            f.write(f"**Generated**: {datetime.now().isoformat()}\n\n")
            f.write(f"**Total Tests**: {len(self.test_results)}\n")
            f.write(f"**Vulnerabilities Proven**: {sum(1 for r in self.test_results if r.vulnerable)}\n\n")
            
            for result in self.test_results:
                f.write(f"## {result.test_name} (ID: {result.test_id})\n\n")
                f.write(f"**Status**: {'✅ VULNERABLE' if result.vulnerable else '❌ NOT VULNERABLE'}\n")
                f.write(f"**Confidence**: {result.confidence:.0%}\n")
                f.write(f"**Severity**: {result.severity}\n")
                f.write(f"**Evidence Type**: {result.evidence_type}\n\n")
                
                f.write("### Endpoint Tested\n")
                f.write(f"- **Path**: `{result.capture_attack.endpoint_path}`\n")
                f.write(f"- **Full URL**: `{result.capture_attack.endpoint_full_url}`\n")
                f.write(f"- **Method**: {result.capture_attack.method}\n\n")
                
                f.write("### Payload\n")
                f.write(f"```\n{result.payload_used}\n```\n\n")
                
                f.write("### Evidence\n")
                f.write(f"{result.evidence_excerpt}\n\n")
                
                if result.baseline_comparison:
                    f.write("### Baseline Comparison\n")
                    bc = result.baseline_comparison
                    f.write(f"| Metric | Benign | Attack | Delta |\n")
                    f.write(f"|--------|--------|--------|-------|\n")
                    f.write(f"| Status Code | {bc.benign_status_code} | {bc.attack_status_code} | " 
                           f"{'✓ Changed' if bc.status_differs else '✗ Same'} |\n")
                    f.write(f"| Response Length | {bc.benign_length} | {bc.attack_length} | "
                           f"{bc.delta_bytes} bytes |\n")
                    f.write(f"| Response Hash | {bc.benign_response_hash[:16]}... | " 
                           f"{bc.attack_response_hash[:16]}... | {'✓ Changed' if bc.hash_differs else '✗ Same'} |\n\n")
                
                f.write("### Benign Response Excerpt\n")
                f.write(f"```\n{result.capture_benign.response_excerpt[:300]}\n```\n\n")
                
                f.write("### Attack Response Excerpt\n")
                f.write(f"```\n{result.capture_attack.response_excerpt[:300]}\n```\n\n")
                
                f.write("---\n\n")
        
        logger.info(f"Markdown report exported to {filename}")
        return filename


# Example usage
if __name__ == "__main__":
    logging.basicConfig(level=logging.INFO)
    
    tester = EnhancedVulnerabilityTester()
    
    # Example: Test a vulnerable app
    # result = tester.test_sql_injection("http://localhost:8000/search")
    # print(f"Vulnerable: {result.vulnerable}, Confidence: {result.confidence:.0%}")
    # tester.export_results_json()
    # tester.export_results_markdown()
    
    print("EnhancedVulnerabilityTester loaded successfully")
