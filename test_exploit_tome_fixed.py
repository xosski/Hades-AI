#!/usr/bin/env python3
"""
Test suite for Exploit Tome functionality
Verifies database operations and integration
"""

import os
import json
import tempfile
from datetime import datetime
from pathlib import Path

from exploit_tome import ExploitTome, ExploitEntry


def test_create_database():
    """Test database creation"""
    print("[*] Testing database creation...")
    
    with tempfile.TemporaryDirectory() as tmpdir:
        db_path = os.path.join(tmpdir, "test_tome.db")
        tome = ExploitTome(db_path)
        
        assert os.path.exists(db_path), "Database file not created"
        assert tome.conn is not None, "Database connection failed"
        print("  [OK] Database created successfully")


def test_exploit_crud():
    """Test Create, Read, Update, Delete operations"""
    print("[*] Testing CRUD operations...")
    
    with tempfile.TemporaryDirectory() as tmpdir:
        db_path = os.path.join(tmpdir, "test_tome.db")
        tome = ExploitTome(db_path)
        
        # CREATE
        exploit = ExploitEntry(
            id="test_001",
            name="Test Exploit",
            category="SQL Injection",
            target="http://test.local/vulnerable.php",
            payload="' OR '1'='1",
            notes="Test notes",
            tags=["test", "sql"],
            cve_ids=["CVE-2024-12345"],
            created_at=datetime.now().isoformat()
        )
        
        assert tome.add_exploit(exploit), "Failed to add exploit"
        print("  [OK] Exploit created")
        
        # READ
        retrieved = tome.get_exploit("test_001")
        assert retrieved is not None, "Failed to retrieve exploit"
        assert retrieved.name == "Test Exploit", "Exploit data mismatch"
        assert retrieved.success_count == 0, "Initial success count should be 0"
        assert "test" in retrieved.tags, "Tags not preserved"
        print("  [OK] Exploit retrieved successfully")
        
        # UPDATE
        assert tome.update_exploit("test_001", notes="Updated notes"), "Update failed"
        updated = tome.get_exploit("test_001")
        assert updated.notes == "Updated notes", "Notes not updated"
        print("  [OK] Exploit updated successfully")
        
        # DELETE
        assert tome.delete_exploit("test_001"), "Delete failed"
        deleted = tome.get_exploit("test_001")
        assert deleted is None, "Exploit should be deleted"
        print("  [OK] Exploit deleted successfully")


def test_search_functionality():
    """Test search and filter operations"""
    print("[*] Testing search functionality...")
    
    with tempfile.TemporaryDirectory() as tmpdir:
        db_path = os.path.join(tmpdir, "test_tome.db")
        tome = ExploitTome(db_path)
        
        # Add test exploits
        exploits = [
            ExploitEntry(
                id="sql_001",
                name="MySQL SQL Injection",
                category="SQL Injection",
                target="http://test.local/search.php",
                payload="' UNION SELECT 1,2,3",
                tags=["sql", "mysql"],
                created_at=datetime.now().isoformat()
            ),
            ExploitEntry(
                id="xss_001",
                name="Reflected XSS",
                category="XSS",
                target="http://test.local/comment.php",
                payload="<script>alert('XSS')</script>",
                tags=["xss", "web"],
                created_at=datetime.now().isoformat()
            ),
            ExploitEntry(
                id="sql_002",
                name="PostgreSQL Injection",
                category="SQL Injection",
                target="http://test.local/login.php",
                payload="'; DROP TABLE users; --",
                tags=["sql", "postgres"],
                created_at=datetime.now().isoformat()
            )
        ]
        
        for exploit in exploits:
            assert tome.add_exploit(exploit), f"Failed to add {exploit.id}"
        
        # Search for SQL
        results = tome.search_exploits("sql")
        assert len(results) >= 2, "SQL search should find SQL exploits"
        print("  [OK] Text search working")
        
        # Filter by category
        sql_exploits = tome.get_all_exploits(category="SQL Injection")
        assert len(sql_exploits) == 2, "Should find 2 SQL injection exploits"
        print("  [OK] Category filtering working")
        
        # Search by tag
        mysql_results = tome.search_exploits("mysql")
        assert len(mysql_results) > 0, "Tag search failed"
        print("  [OK] Tag search working")


def test_execution_tracking():
    """Test execution history logging"""
    print("[*] Testing execution tracking...")
    
    with tempfile.TemporaryDirectory() as tmpdir:
        db_path = os.path.join(tmpdir, "test_tome.db")
        tome = ExploitTome(db_path)
        
        # Create exploit
        exploit = ExploitEntry(
            id="test_exec",
            name="Test Exploit",
            category="Test",
            target="http://test.local",
            payload="test",
            created_at=datetime.now().isoformat()
        )
        tome.add_exploit(exploit)
        
        # Log executions
        assert tome.log_execution(
            "test_exec", "http://test.local", "success", "response data"
        ), "Failed to log success"
        
        assert tome.log_execution(
            "test_exec", "http://test.local", "failure", error="Connection failed"
        ), "Failed to log failure"
        
        # Check counts updated
        updated = tome.get_exploit("test_exec")
        assert updated.success_count == 1, f"Success count should be 1, got {updated.success_count}"
        assert updated.fail_count == 1, f"Fail count should be 1, got {updated.fail_count}"
        print("  [OK] Success/failure counts updated")
        
        # Get history
        history = tome.get_execution_history("test_exec")
        assert len(history) == 2, f"Should have 2 history entries, got {len(history)}"
        assert history[0]['result'] == 'failure', "Most recent should be failure"
        print("  [OK] Execution history recorded")
        
        # Test success rate
        rate = updated.get_success_rate()
        assert rate == 50.0, f"Success rate should be 50%, got {rate}%"
        print("  [OK] Success rate calculation correct")


def test_collections():
    """Test collection management"""
    print("[*] Testing collections...")
    
    with tempfile.TemporaryDirectory() as tmpdir:
        db_path = os.path.join(tmpdir, "test_tome.db")
        tome = ExploitTome(db_path)
        
        # Create exploits
        for i in range(3):
            exploit = ExploitEntry(
                id=f"test_{i}",
                name=f"Test Exploit {i}",
                category="Test",
                target=f"http://test.local/{i}",
                payload="test",
                created_at=datetime.now().isoformat()
            )
            tome.add_exploit(exploit)
        
        # Create collection
        assert tome.create_collection("Test Collection", "Test description"), \
            "Failed to create collection"
        print("  [OK] Collection created")
        
        # Add exploits to collection
        for i in range(3):
            assert tome.add_to_collection("Test Collection", f"test_{i}"), \
                f"Failed to add test_{i} to collection"
        print("  [OK] Exploits added to collection")
        
        # Get collection members
        members = tome.get_collection_exploits("Test Collection")
        assert len(members) == 3, f"Should have 3 members, got {len(members)}"
        print("  [OK] Collection members retrieved")
        
        # Get collections
        collections = tome.get_collections()
        assert len(collections) > 0, "No collections found"
        print("  [OK] Collections listing working")


def test_statistics():
    """Test statistics generation"""
    print("[*] Testing statistics...")
    
    with tempfile.TemporaryDirectory() as tmpdir:
        db_path = os.path.join(tmpdir, "test_tome.db")
        tome = ExploitTome(db_path)
        
        # Add exploits with various success rates
        for category in ["SQL Injection", "XSS", "RCE"]:
            for i in range(2):
                exploit = ExploitEntry(
                    id=f"{category.replace(' ', '_').lower()}_{i}",
                    name=f"{category} Exploit {i}",
                    category=category,
                    target=f"http://test.local/{i}",
                    payload="test",
                    success_count=i * 2,
                    fail_count=i,
                    created_at=datetime.now().isoformat()
                )
                tome.add_exploit(exploit)
        
        # Get statistics
        stats = tome.get_statistics()
        
        assert stats['total_exploits'] == 6, f"Should have 6 exploits, got {stats['total_exploits']}"
        assert len(stats['by_category']) == 3, f"Should have 3 categories, got {len(stats['by_category'])}"
        assert 'overall_success_rate' in stats, "Missing success rate"
        assert 'most_successful' in stats, "Missing most successful"
        
        print("  [OK] Statistics generated correctly")
        print(f"    Total exploits: {stats['total_exploits']}")
        print(f"    Categories: {list(stats['by_category'].keys())}")
        print(f"    Overall success rate: {stats['overall_success_rate']:.1f}%")


def test_export_import():
    """Test JSON export/import"""
    print("[*] Testing export/import...")
    
    with tempfile.TemporaryDirectory() as tmpdir:
        # Create and populate first database
        db1_path = os.path.join(tmpdir, "tome1.db")
        tome1 = ExploitTome(db1_path)
        
        exploits = [
            ExploitEntry(
                id="exp_001",
                name="Export Test 1",
                category="Test",
                target="http://test.local/1",
                payload="test payload 1",
                tags=["test", "export"],
                created_at=datetime.now().isoformat()
            ),
            ExploitEntry(
                id="exp_002",
                name="Export Test 2",
                category="Test",
                target="http://test.local/2",
                payload="test payload 2",
                tags=["test", "export"],
                created_at=datetime.now().isoformat()
            )
        ]
        
        for exploit in exploits:
            tome1.add_exploit(exploit)
        
        # Export
        export_file = os.path.join(tmpdir, "export.json")
        assert tome1.export_to_json(export_file), "Export failed"
        assert os.path.exists(export_file), "Export file not created"
        print("  [OK] Exploits exported to JSON")
        
        # Verify export file
        with open(export_file, 'r') as f:
            data = json.load(f)
        assert len(data['exploits']) == 2, "Export should have 2 exploits"
        print("  [OK] Export file validated")
        
        # Create second database and import
        db2_path = os.path.join(tmpdir, "tome2.db")
        tome2 = ExploitTome(db2_path)
        
        count = tome2.import_from_json(export_file)
        assert count == 2, f"Should import 2 exploits, got {count}"
        print("  [OK] Exploits imported from JSON")
        
        # Verify import
        imported = tome2.get_all_exploits()
        assert len(imported) == 2, "Should have 2 imported exploits"
        assert imported[0].payload in ["test payload 1", "test payload 2"], "Payload not preserved"
        print("  [OK] Import data validated")


def test_categories():
    """Test category management"""
    print("[*] Testing categories...")
    
    with tempfile.TemporaryDirectory() as tmpdir:
        db_path = os.path.join(tmpdir, "test_tome.db")
        tome = ExploitTome(db_path)
        
        categories = ["SQL Injection", "XSS", "RCE", "CSRF"]
        
        # Create exploits in different categories
        for cat in categories:
            exploit = ExploitEntry(
                id=f"cat_{cat.replace(' ', '_').lower()}",
                name=f"{cat} Exploit",
                category=cat,
                target="http://test.local",
                payload="test",
                created_at=datetime.now().isoformat()
            )
            tome.add_exploit(exploit)
        
        # Get categories
        found_categories = tome.get_categories()
        assert len(found_categories) == 4, f"Should have 4 categories, got {len(found_categories)}"
        
        for cat in categories:
            assert cat in found_categories, f"Category '{cat}' not found"
        
        print("  [OK] Categories retrieved correctly")


def test_error_handling():
    """Test error handling and edge cases"""
    print("[*] Testing error handling...")
    
    with tempfile.TemporaryDirectory() as tmpdir:
        db_path = os.path.join(tmpdir, "test_tome.db")
        tome = ExploitTome(db_path)
        
        # Get non-existent exploit
        result = tome.get_exploit("non_existent")
        assert result is None, "Should return None for non-existent exploit"
        print("  [OK] Handles non-existent exploits gracefully")
        
        # Search with empty term
        results = tome.search_exploits("")
        assert isinstance(results, list), "Search should return list"
        print("  [OK] Handles empty search")
        
        # Get history for non-existent exploit
        history = tome.get_execution_history("non_existent")
        assert history == [], "Should return empty list"
        print("  [OK] Handles missing execution history")
        
        # Delete non-existent exploit
        result = tome.delete_exploit("non_existent")
        assert result is False, "Delete non-existent should return False"
        print("  [OK] Handles delete non-existent")


def run_all_tests():
    """Run complete test suite"""
    print("\n" + "="*60)
    print("TEST SUITE: Exploit Tome")
    print("="*60 + "\n")
    
    try:
        test_create_database()
        test_exploit_crud()
        test_search_functionality()
        test_execution_tracking()
        test_collections()
        test_statistics()
        test_export_import()
        test_categories()
        test_error_handling()
        
        print("\n" + "="*60)
        print("SUCCESS: ALL TESTS PASSED!")
        print("="*60 + "\n")
        return True
        
    except AssertionError as e:
        print(f"\nFAILED: {e}\n")
        return False
    except Exception as e:
        print(f"\nERROR: {e}\n")
        import traceback
        traceback.print_exc()
        return False


if __name__ == "__main__":
    success = run_all_tests()
    exit(0 if success else 1)
