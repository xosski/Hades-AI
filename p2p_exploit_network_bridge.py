"""
Bridge between P2P Exploit Sharing and KnowledgeNetworkNode
Handles message routing and synchronization
"""

import json
import logging
from typing import Dict, Optional, Callable
from p2p_exploit_sharing import P2PExploitSharer, ExploitFinding

logger = logging.getLogger("P2PExploitNetworkBridge")


class ExploitNetworkBridge:
    """
    Bridges P2P exploit sharing with KnowledgeNetworkNode
    Handles bidirectional message conversion and routing
    """
    
    def __init__(self, exploit_sharer: P2PExploitSharer):
        self.exploit_sharer = exploit_sharer
        self.message_handlers = {
            'share_exploit': self._handle_share_exploit,
            'seek_exploits': self._handle_seek_exploits,
            'exploit_response': self._handle_exploit_response,
        }
    
    def integrate_with_network(self, network_node):
        """
        Integrate with network node
        Call this after network is initialized
        """
        self.exploit_sharer.network_node = network_node
        
        # Register message handler with network
        if hasattr(network_node, 'register_message_handler'):
            network_node.register_message_handler('exploit_sharing', self.handle_network_message)
        
        logger.info("Exploit sharing integrated with network")
    
    def handle_network_message(self, message: Dict, peer_id: str) -> bool:
        """
        Handle incoming network message about exploits
        Called by network node when exploit_sharing message received
        """
        try:
            action = message.get('action', '')
            handler = self.message_handlers.get(action)
            
            if handler:
                return handler(message, peer_id)
            else:
                logger.warning(f"Unknown exploit action: {action}")
                return False
        except Exception as e:
            logger.error(f"Error handling network message: {e}")
            return False
    
    def _handle_share_exploit(self, message: Dict, peer_id: str) -> bool:
        """Handle incoming exploit sharing"""
        try:
            exploit_data = message.get('exploit', {})
            
            # Convert to ExploitFinding
            exploit = ExploitFinding(
                exploit_id=exploit_data['exploit_id'],
                target_url=exploit_data['target_url'],
                exploit_type=exploit_data['exploit_type'],
                severity=exploit_data['severity'],
                payload=exploit_data['payload'],
                description=exploit_data['description'],
                timestamp=exploit_data['timestamp'],
                instance_id=exploit_data['instance_id'],
                success=exploit_data.get('success', False),
                impact=exploit_data.get('impact', ''),
                remediation=exploit_data.get('remediation', ''),
                metadata=exploit_data.get('metadata', {})
            )
            
            # Receive in sharer
            self.exploit_sharer.receive_exploit(exploit_data, peer_id)
            
            logger.info(f"Received {exploit.exploit_type} from {peer_id}")
            return True
        except Exception as e:
            logger.error(f"Error handling share_exploit: {e}")
            return False
    
    def _handle_seek_exploits(self, message: Dict, peer_id: str) -> bool:
        """Handle exploit seek request from peer"""
        try:
            target_url = message.get('target_url', '')
            requester = message.get('requester', peer_id)
            
            logger.info(f"Peer {requester} seeking exploits for {target_url}")
            
            # Find matching exploits
            exploits = self.exploit_sharer.registry.get_exploits_by_url(target_url)
            
            # Send response back
            response = {
                'type': 'exploit_sharing',
                'action': 'exploit_response',
                'target_url': target_url,
                'exploits': [e.to_dict() for e in exploits],
                'source': self.exploit_sharer.instance_id,
            }
            
            if self.exploit_sharer.network_node:
                self.exploit_sharer.network_node.send_message(requester, response)
            
            logger.info(f"Responded with {len(exploits)} exploits")
            return True
        except Exception as e:
            logger.error(f"Error handling seek_exploits: {e}")
            return False
    
    def _handle_exploit_response(self, message: Dict, peer_id: str) -> bool:
        """Handle exploit response to seek request"""
        try:
            exploits = message.get('exploits', [])
            
            logger.info(f"Received {len(exploits)} exploits in response from {peer_id}")
            
            # Process each exploit
            for exploit_data in exploits:
                self.exploit_sharer.receive_exploit(exploit_data, peer_id)
            
            return True
        except Exception as e:
            logger.error(f"Error handling exploit_response: {e}")
            return False


class NetworkExploitListener:
    """
    Listens to network events and automatically shares exploits
    Integrates with simulation engine to catch discoveries
    """
    
    def __init__(self, exploit_sharer: P2PExploitSharer):
        self.exploit_sharer = exploit_sharer
        self.bridge = ExploitNetworkBridge(exploit_sharer)
    
    def on_simulation_exploit_found(self, target_url: str, exploit_type: str, 
                                    payload: str, success: bool = True,
                                    description: str = "", severity: str = "High"):
        """
        Called when simulation finds an exploit
        Automatically registers and shares it
        """
        import time
        import uuid
        
        exploit = ExploitFinding(
            exploit_id=str(uuid.uuid4()),
            target_url=target_url,
            exploit_type=exploit_type,
            severity=severity,
            payload=payload,
            description=description or f"Exploit discovered in simulation",
            timestamp=time.time(),
            instance_id=self.exploit_sharer.instance_id,
            success=success
        )
        
        # Register locally
        self.exploit_sharer.register_exploit(exploit)
        
        logger.info(f"Registered and shared {exploit_type} exploit")
    
    def on_attack_vector_success(self, attack_vector_data: Dict):
        """
        Called when attack vector succeeds
        Extracts exploit info and shares
        """
        try:
            target = attack_vector_data.get('target', '')
            vector_name = attack_vector_data.get('vector', '')
            payload = attack_vector_data.get('payload', '')
            
            # Map vector to exploit type
            exploit_type_map = {
                'sql_injection': 'sql_injection',
                'xss': 'xss',
                'command_injection': 'rce',
                'ssrf': 'ssrf',
                'jwt': 'jwt_bypass',
                'authentication_bypass': 'auth_bypass',
            }
            
            exploit_type = exploit_type_map.get(
                vector_name.lower(),
                'unknown'
            )
            
            self.on_simulation_exploit_found(
                target_url=target,
                exploit_type=exploit_type,
                payload=payload,
                success=True,
                description=f"Success with attack vector: {vector_name}",
                severity="Critical"
            )
        except Exception as e:
            logger.error(f"Error processing attack vector success: {e}")


def integrate_exploit_sharing_with_network(exploit_sharer: P2PExploitSharer, 
                                          network_node) -> ExploitNetworkBridge:
    """
    Convenience function to integrate exploit sharing with network
    
    Usage in HadesAI:
    ```python
    from p2p_exploit_network_bridge import integrate_exploit_sharing_with_network
    
    bridge = integrate_exploit_sharing_with_network(
        self.exploit_sharer,
        self.network_node
    )
    ```
    """
    bridge = ExploitNetworkBridge(exploit_sharer)
    bridge.integrate_with_network(network_node)
    
    # Start exploit sharer
    exploit_sharer.network_node = network_node
    exploit_sharer.start()
    
    return bridge


def create_exploit_listener(exploit_sharer: P2PExploitSharer) -> NetworkExploitListener:
    """
    Create an exploit listener for hooking into simulation/attack events
    
    Usage:
    ```python
    listener = create_exploit_listener(exploit_sharer)
    
    # Hook into simulation events
    simulation_engine.on_exploit_found = listener.on_simulation_exploit_found
    
    # Hook into attack events
    attack_engine.on_success = listener.on_attack_vector_success
    ```
    """
    return NetworkExploitListener(exploit_sharer)


# Example integration code (for documentation)

INTEGRATION_EXAMPLE = '''
# In HadesAI.__init__():

# Initialize exploit sharing
self.exploit_sharer = P2PExploitSharer(instance_id=self.get_instance_id())
self.exploit_network_bridge = None
self.exploit_listener = None

# Create seek tab
if HAS_P2P_EXPLOIT_SHARING:
    self.exploit_seek_tab = create_exploit_seek_tab(
        parent=self,
        exploit_sharer=self.exploit_sharer
    )
    self.tabs.addTab(self.exploit_seek_tab, "üîç Exploit Seek")


# In the network enable function:

def enable_network_sharing(self):
    # ... existing network code ...
    
    # Integrate exploit sharing with network
    from p2p_exploit_network_bridge import integrate_exploit_sharing_with_network
    
    self.exploit_network_bridge = integrate_exploit_sharing_with_network(
        self.exploit_sharer,
        self.network_node
    )
    
    # Create listener for automatic sharing
    from p2p_exploit_network_bridge import create_exploit_listener
    
    self.exploit_listener = create_exploit_listener(self.exploit_sharer)
    
    # Hook into simulation engine if available
    if self.simulation_engine:
        self.simulation_engine.on_exploit_found = self.exploit_listener.on_simulation_exploit_found


# When simulation discovers an exploit:

exploit_found_data = {
    'target': 'https://target.com/login',
    'type': 'sql_injection',
    'payload': "admin'--",
    'success': True
}

self.exploit_listener.on_simulation_exploit_found(
    target_url=exploit_found_data['target'],
    exploit_type=exploit_found_data['type'],
    payload=exploit_found_data['payload'],
    success=exploit_found_data['success'],
    severity='Critical'
)
'''
