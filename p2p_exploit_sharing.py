"""
P2P Exploit Sharing & Discovery System
Automatically shares discovered exploits across P2P network
Provides seek/search functionality for exploit discovery
"""

import json
import threading
import time
import logging
from typing import Dict, List, Optional, Callable
from dataclasses import dataclass, asdict
from datetime import datetime
from urllib.parse import urlparse

logger = logging.getLogger("P2PExploitSharing")


@dataclass
class ExploitFinding:
    """Represents a discovered exploit or vulnerability"""
    exploit_id: str
    target_url: str
    exploit_type: str  # sql_injection, xss, rce, ssrf, jwt_bypass, etc.
    severity: str  # Critical, High, Medium, Low
    payload: str
    description: str
    timestamp: float
    instance_id: str  # Which instance discovered it
    success: bool = False
    impact: str = ""
    remediation: str = ""
    metadata: Dict = None
    
    def to_dict(self):
        return {
            'exploit_id': self.exploit_id,
            'target_url': self.target_url,
            'exploit_type': self.exploit_type,
            'severity': self.severity,
            'payload': self.payload,
            'description': self.description,
            'timestamp': self.timestamp,
            'instance_id': self.instance_id,
            'success': self.success,
            'impact': self.impact,
            'remediation': self.remediation,
            'metadata': self.metadata or {}
        }


class ExploitRegistry:
    """Local registry of discovered exploits"""
    
    def __init__(self):
        self.exploits: Dict[str, ExploitFinding] = {}
        self.lock = threading.Lock()
        self.listeners: List[Callable] = []
    
    def register_exploit(self, exploit: ExploitFinding):
        """Register a discovered exploit"""
        with self.lock:
            self.exploits[exploit.exploit_id] = exploit
            logger.info(f"Registered exploit: {exploit.exploit_type} on {exploit.target_url}")
            self._notify_listeners(exploit)
    
    def get_exploit(self, exploit_id: str) -> Optional[ExploitFinding]:
        """Retrieve exploit by ID"""
        with self.lock:
            return self.exploits.get(exploit_id)
    
    def get_exploits_by_type(self, exploit_type: str) -> List[ExploitFinding]:
        """Get all exploits of a specific type"""
        with self.lock:
            return [e for e in self.exploits.values() if e.exploit_type == exploit_type]
    
    def get_exploits_by_url(self, target_url: str) -> List[ExploitFinding]:
        """Get all exploits for a specific target URL"""
        with self.lock:
            return [e for e in self.exploits.values() if e.target_url == target_url]
    
    def get_critical_exploits(self) -> List[ExploitFinding]:
        """Get all critical severity exploits"""
        with self.lock:
            return [e for e in self.exploits.values() if e.severity == 'Critical']
    
    def get_all_exploits(self) -> List[ExploitFinding]:
        """Get all registered exploits"""
        with self.lock:
            return list(self.exploits.values())
    
    def subscribe(self, callback: Callable):
        """Subscribe to exploit registration events"""
        self.listeners.append(callback)
    
    def _notify_listeners(self, exploit: ExploitFinding):
        """Notify all subscribers of new exploit"""
        for listener in self.listeners:
            try:
                listener(exploit)
            except Exception as e:
                logger.error(f"Error notifying listener: {e}")


class P2PExploitSharer:
    """Handles P2P sharing of exploits with network peers"""
    
    def __init__(self, network_node=None, instance_id: str = ""):
        self.network_node = network_node
        self.instance_id = instance_id
        self.registry = ExploitRegistry()
        self.shared_exploits: Dict[str, float] = {}  # exploit_id -> last_shared_time
        self.received_exploits: Dict[str, ExploitFinding] = {}
        self.lock = threading.Lock()
        self.sync_interval = 30  # seconds
        self.sync_thread = None
        self.running = False
    
    def start(self):
        """Start background sync thread"""
        if self.running:
            return
        
        self.running = True
        self.sync_thread = threading.Thread(target=self._sync_loop, daemon=True)
        self.sync_thread.start()
        logger.info("P2P Exploit Sharing started")
    
    def stop(self):
        """Stop background sync thread"""
        self.running = False
        if self.sync_thread:
            self.sync_thread.join(timeout=5)
        logger.info("P2P Exploit Sharing stopped")
    
    def register_exploit(self, exploit: ExploitFinding):
        """Register a local exploit discovery"""
        self.registry.register_exploit(exploit)
        
        # Mark for sharing
        with self.lock:
            self.shared_exploits[exploit.exploit_id] = time.time()
        
        # Immediately share if network available
        if self.network_node:
            self._broadcast_exploit(exploit)
    
    def _broadcast_exploit(self, exploit: ExploitFinding):
        """Broadcast exploit to all peers"""
        if not self.network_node:
            return
        
        try:
            message = {
                'type': 'exploit_sharing',
                'action': 'share_exploit',
                'exploit': exploit.to_dict(),
                'source_instance': self.instance_id,
                'timestamp': time.time()
            }
            
            # Share to all trusted peers
            for peer_id in self.network_node.get_trusted_peers():
                self.network_node.send_message(peer_id, message)
                logger.info(f"Shared exploit {exploit.exploit_id} with peer {peer_id}")
        except Exception as e:
            logger.error(f"Failed to broadcast exploit: {e}")
    
    def receive_exploit(self, exploit_data: Dict, source_peer: str):
        """Receive exploit from peer"""
        try:
            exploit = ExploitFinding(
                exploit_id=exploit_data['exploit_id'],
                target_url=exploit_data['target_url'],
                exploit_type=exploit_data['exploit_type'],
                severity=exploit_data['severity'],
                payload=exploit_data['payload'],
                description=exploit_data['description'],
                timestamp=exploit_data['timestamp'],
                instance_id=exploit_data['instance_id'],
                success=exploit_data.get('success', False),
                impact=exploit_data.get('impact', ''),
                remediation=exploit_data.get('remediation', ''),
                metadata=exploit_data.get('metadata', {})
            )
            
            with self.lock:
                self.received_exploits[exploit.exploit_id] = exploit
            
            logger.info(f"Received exploit {exploit.exploit_id} from {source_peer}")
            return True
        except Exception as e:
            logger.error(f"Failed to process received exploit: {e}")
            return False
    
    def seek_exploits(self, target_url: str, callback: Callable = None) -> List[ExploitFinding]:
        """
        Search for exploits for a target URL
        Queries local registry and broadcasts seek request to network
        """
        logger.info(f"Seeking exploits for {target_url}")
        
        # Get local exploits first
        local_exploits = self.registry.get_exploits_by_url(target_url)
        
        # Request from peers
        if self.network_node:
            self._broadcast_seek_request(target_url)
        
        results = local_exploits + list(self.received_exploits.values())
        results = [e for e in results if e.target_url == target_url]
        
        if callback:
            callback(results)
        
        return results
    
    def _broadcast_seek_request(self, target_url: str):
        """Request exploit information from network peers"""
        if not self.network_node:
            return
        
        try:
            message = {
                'type': 'exploit_sharing',
                'action': 'seek_exploits',
                'target_url': target_url,
                'requester': self.instance_id,
                'timestamp': time.time()
            }
            
            for peer_id in self.network_node.get_all_peers():
                self.network_node.send_message(peer_id, message)
        except Exception as e:
            logger.error(f"Failed to broadcast seek request: {e}")
    
    def get_exploits_by_type(self, exploit_type: str) -> List[ExploitFinding]:
        """Get all exploits of specific type from local + network"""
        local = self.registry.get_exploits_by_type(exploit_type)
        network = [e for e in self.received_exploits.values() 
                  if e.exploit_type == exploit_type]
        return local + network
    
    def get_critical_exploits(self) -> List[ExploitFinding]:
        """Get all critical severity exploits"""
        local = self.registry.get_critical_exploits()
        network = [e for e in self.received_exploits.values() 
                  if e.severity == 'Critical']
        return local + network
    
    def get_network_statistics(self) -> Dict:
        """Get statistics about shared exploits"""
        all_exploits = self.registry.get_all_exploits() + list(self.received_exploits.values())
        
        return {
            'total_exploits': len(all_exploits),
            'local_exploits': len(self.registry.get_all_exploits()),
            'received_exploits': len(self.received_exploits),
            'critical_count': len([e for e in all_exploits if e.severity == 'Critical']),
            'high_count': len([e for e in all_exploits if e.severity == 'High']),
            'exploits_by_type': self._group_by_type(all_exploits),
            'shared_count': len(self.shared_exploits)
        }
    
    def _group_by_type(self, exploits: List[ExploitFinding]) -> Dict[str, int]:
        """Group exploits by type"""
        grouped = {}
        for exploit in exploits:
            grouped[exploit.exploit_type] = grouped.get(exploit.exploit_type, 0) + 1
        return grouped
    
    def _sync_loop(self):
        """Periodic sync with network"""
        while self.running:
            try:
                time.sleep(self.sync_interval)
                
                if self.network_node:
                    # Sync shared exploits with peers
                    exploits_to_share = [
                        self.registry.get_exploit(exp_id)
                        for exp_id in self.shared_exploits.keys()
                    ]
                    
                    for exploit in exploits_to_share:
                        if exploit:
                            self._broadcast_exploit(exploit)
            except Exception as e:
                logger.error(f"Sync error: {e}")
    
    def export_exploits(self, filename: str = None) -> str:
        """Export exploits to JSON file"""
        all_exploits = self.registry.get_all_exploits()
        data = {
            'instance_id': self.instance_id,
            'export_time': time.time(),
            'exploits': [e.to_dict() for e in all_exploits],
            'statistics': self.get_network_statistics()
        }
        
        if not filename:
            filename = f"exploits_export_{int(time.time())}.json"
        
        with open(filename, 'w') as f:
            json.dump(data, f, indent=2)
        
        logger.info(f"Exported {len(all_exploits)} exploits to {filename}")
        return filename
    
    def import_exploits(self, filename: str) -> int:
        """Import exploits from JSON file"""
        try:
            with open(filename, 'r') as f:
                data = json.load(f)
            
            count = 0
            for exploit_data in data.get('exploits', []):
                exploit = ExploitFinding(
                    exploit_id=exploit_data['exploit_id'],
                    target_url=exploit_data['target_url'],
                    exploit_type=exploit_data['exploit_type'],
                    severity=exploit_data['severity'],
                    payload=exploit_data['payload'],
                    description=exploit_data['description'],
                    timestamp=exploit_data['timestamp'],
                    instance_id=exploit_data['instance_id'],
                    success=exploit_data.get('success', False),
                    impact=exploit_data.get('impact', ''),
                    remediation=exploit_data.get('remediation', ''),
                    metadata=exploit_data.get('metadata', {})
                )
                self.registry.register_exploit(exploit)
                count += 1
            
            logger.info(f"Imported {count} exploits from {filename}")
            return count
        except Exception as e:
            logger.error(f"Failed to import exploits: {e}")
            return 0


class ExploitSeeker:
    """Intelligent exploit seeker with auto-attempt capabilities"""
    
    def __init__(self, exploit_sharer: P2PExploitSharer, simulation_engine=None):
        self.sharer = exploit_sharer
        self.simulation_engine = simulation_engine
        self.active_searches: Dict[str, Dict] = {}
        self.lock = threading.Lock()
    
    def seek_and_attempt(self, target_url: str, callback: Callable = None) -> Dict:
        """
        Seek exploits for target and attempt them
        Returns results with success/failure info
        """
        logger.info(f"Starting seek and attempt for {target_url}")
        
        # Parse target
        parsed = urlparse(target_url)
        target_domain = parsed.netloc or parsed.path
        
        # Search for exploits
        exploits = self.sharer.seek_exploits(target_url)
        
        if not exploits:
            result = {
                'target': target_url,
                'status': 'no_exploits_found',
                'attempts': [],
                'timestamp': time.time()
            }
        else:
            result = {
                'target': target_url,
                'status': 'attempting',
                'attempts': [],
                'timestamp': time.time()
            }
            
            # Attempt exploits (prioritize by severity)
            sorted_exploits = sorted(exploits, 
                                   key=lambda e: {'Critical': 0, 'High': 1, 'Medium': 2, 'Low': 3}.get(e.severity, 4))
            
            for exploit in sorted_exploits:
                attempt_result = self._attempt_exploit(exploit, target_url)
                result['attempts'].append(attempt_result)
                
                if attempt_result['success']:
                    result['status'] = 'exploited'
                    break
        
        if callback:
            callback(result)
        
        return result
    
    def _attempt_exploit(self, exploit: ExploitFinding, target_url: str) -> Dict:
        """Attempt a single exploit"""
        logger.info(f"Attempting {exploit.exploit_type} on {target_url}")
        
        try:
            # Check if this is a simulation or real attempt
            if self.simulation_engine:
                success = self.simulation_engine.simulate_exploit(exploit, target_url)
            else:
                # Real attempt would go here
                success = False
            
            return {
                'exploit_id': exploit.exploit_id,
                'exploit_type': exploit.exploit_type,
                'success': success,
                'timestamp': time.time(),
                'payload': exploit.payload[:100] + '...' if len(exploit.payload) > 100 else exploit.payload
            }
        except Exception as e:
            logger.error(f"Attempt failed: {e}")
            return {
                'exploit_id': exploit.exploit_id,
                'exploit_type': exploit.exploit_type,
                'success': False,
                'error': str(e),
                'timestamp': time.time()
            }
    
    def get_search_status(self, search_id: str) -> Optional[Dict]:
        """Get status of active search"""
        with self.lock:
            return self.active_searches.get(search_id)
    
    def cancel_search(self, search_id: str):
        """Cancel active search"""
        with self.lock:
            if search_id in self.active_searches:
                del self.active_searches[search_id]
                logger.info(f"Cancelled search {search_id}")
