"""
Exploit Seek & Share Tab for HadesAI - AI Enhanced
Provides UI for P2P exploit searching and AI-powered vulnerability testing
"""

from PyQt6.QtWidgets import (
    QWidget, QVBoxLayout, QHBoxLayout, QGroupBox, QLabel, QPushButton,
    QLineEdit, QTextEdit, QTableWidget, QTableWidgetItem, QProgressBar,
    QComboBox, QCheckBox, QSpinBox, QTabWidget, QMessageBox, QListWidget,
    QListWidgetItem, QSplitter, QStatusBar, QFormLayout
)
from PyQt6.QtCore import Qt, QThread, pyqtSignal, QTimer
from PyQt6.QtGui import QFont, QColor, QIcon
import json
import time
import logging
from typing import Optional, Callable, Dict, List
from p2p_exploit_sharing import (
    P2PExploitSharer, ExploitSeeker, ExploitFinding
)

logger = logging.getLogger("ExploitSeekTab")

try:
    from comprehensive_exploit_seeker import UnifiedExploitKnowledge
    HAS_UNIFIED_SEEKER = True
except ImportError:
    UnifiedExploitKnowledge = None
    HAS_UNIFIED_SEEKER = False

try:
    from ai_vulnerability_tester import AIVulnerabilityTester
    HAS_AI_TESTER = True
except ImportError:
    AIVulnerabilityTester = None
    HAS_AI_TESTER = False


class SeekWorker(QThread):
    """Background worker for exploit seeking"""
    finished = pyqtSignal(dict)
    progress = pyqtSignal(str)
    error = pyqtSignal(str)
    
    def __init__(self, seeker: ExploitSeeker, target_url: str):
        super().__init__()
        self.seeker = seeker
        self.target_url = target_url
        self.setObjectName("SeekWorker")
    
    def run(self):
        try:
            self.progress.emit(f"Seeking exploits for {self.target_url}...")
            result = self.seeker.seek_and_attempt(
                self.target_url,
                callback=self._progress_callback
            )
            if result:
                self.finished.emit(result)
            else:
                self.error.emit("No result returned from seek")
        except Exception as e:
            self.error.emit(str(e))
    
    def _progress_callback(self, result: dict):
        if result:
            self.progress.emit(f"Exploit attempts: {len(result.get('attempts', []))}")


class UnifiedSeekWorker(QThread):
    """Background worker for unified exploit seeking from all sources"""
    finished = pyqtSignal(dict)
    progress = pyqtSignal(str)
    enumeration_progress = pyqtSignal(str)  # Per-source progress
    error = pyqtSignal(str)
    
    def __init__(self, unified_seeker, target_url: str):
        super().__init__()
        self.unified_seeker = unified_seeker
        self.target_url = target_url
        self.setObjectName("UnifiedSeekWorker")
    
    def run(self):
        try:
            self.progress.emit("Initiating comprehensive exploit enumeration...")
            self.enumeration_progress.emit("Searching 7 knowledge sources...")
            
            # Get exploits from all sources
            exploits = self.unified_seeker.seek_all_exploits(self.target_url)
            
            # Get source statistics
            source_stats = self.unified_seeker.get_source_stats(exploits)
            source_info = "\n".join([f"  {src}: {cnt}" for src, cnt in source_stats.items()])
            
            self.progress.emit(f"Enumeration complete: {len(exploits)} total exploits found")
            self.enumeration_progress.emit(f"Source breakdown:\n{source_info}")
            
            # Convert exploits to attempts format (dicts with all details)
            attempts = []
            for i, exploit in enumerate(exploits, 1):
                attempt = {
                    'exploit_id': exploit.get('id', f'exploit_{i}'),
                    'exploit_type': exploit.get('type', 'Unknown'),
                    'severity': exploit.get('severity', 'Medium'),
                    'payload': exploit.get('payload', ''),
                    'description': exploit.get('description', ''),
                    'success': exploit.get('success', False),
                    'confidence': exploit.get('confidence', 0.5),
                    'source': exploit.get('source', 'Unknown'),
                    'impact': exploit.get('impact', ''),
                    'remediation': exploit.get('remediation', ''),
                    'timestamp': exploit.get('timestamp', time.time())
                }
                attempts.append(attempt)
            
            # Prepare result
            result = {
                'target': self.target_url,
                'status': 'completed' if len(attempts) > 0 else 'no_exploits_found',
                'attempts': attempts,
                'timestamp': time.time(),
                'total_exploits': len(attempts),
                'sources': source_stats,
                'enumeration_complete': True
            }
            
            self.finished.emit(result)
        except Exception as e:
            import traceback
            error_detail = f"Comprehensive seek error: {str(e)}\n{traceback.format_exc()}"
            logger.error(error_detail)
            self.error.emit(error_detail)


class AIVulnerabilityWorker(QThread):
    """Background worker for AI-powered vulnerability testing"""
    finished = pyqtSignal(dict)
    progress = pyqtSignal(str)
    error = pyqtSignal(str)
    
    def __init__(self, tester: 'AIVulnerabilityTester', target_url: str, test_categories: List[str] = None):
        super().__init__()
        self.tester = tester
        self.target_url = target_url
        self.test_categories = test_categories or ['injection', 'authentication', 'configuration']
        self.setObjectName("AIVulnerabilityWorker")
    
    def run(self):
        try:
            result = self.tester.test_website(
                self.target_url,
                test_categories=self.test_categories,
                callback=lambda msg: self.progress.emit(msg)
            )
            self.finished.emit(result)
        except Exception as e:
            import traceback
            error_detail = f"AI Vulnerability Test Error: {str(e)}\n{traceback.format_exc()}"
            logger.error(error_detail)
            self.error.emit(error_detail)


class ExploitSeekTab(QWidget):
    """Tab for exploit seeking and P2P sharing - Enhanced with AI Testing"""
    
    def __init__(self, parent=None, exploit_sharer: P2PExploitSharer = None, hades_ai=None):
        super().__init__(parent)
        self.exploit_sharer = exploit_sharer or P2PExploitSharer()
        self.hades_ai = hades_ai
        self.exploit_seeker = ExploitSeeker(self.exploit_sharer)
        
        # Use unified seeker if available
        self.unified_seeker = None
        if HAS_UNIFIED_SEEKER and hades_ai:
            self.unified_seeker = UnifiedExploitKnowledge(hades_ai, exploit_sharer)
        
        # Initialize AI vulnerability tester
        self.ai_tester = None
        if HAS_AI_TESTER:
            self.ai_tester = AIVulnerabilityTester(hades_ai)
        
        self.seek_worker = None
        self.ai_worker = None
        self.current_search_results = {}
        self.current_ai_results = {}
        self.init_ui()
        
        # Auto-refresh shared exploits
        self.refresh_timer = QTimer()
        self.refresh_timer.timeout.connect(self._refresh_shared_exploits)
        self.refresh_timer.start(5000)  # Every 5 seconds
    
    def closeEvent(self, event):
        """Cleanup threads on close"""
        self.refresh_timer.stop()
        if self.seek_worker and self.seek_worker.isRunning():
            self.seek_worker.quit()
            self.seek_worker.wait()
        if self.ai_worker and self.ai_worker.isRunning():
            self.ai_worker.quit()
            self.ai_worker.wait()
        super().closeEvent(event)
    
    def init_ui(self):
        layout = QVBoxLayout(self)
        
        # ===== SEEK SECTION =====
        seek_group = QGroupBox("ðŸ” Exploit Seeker + ðŸ¤– AI Tester")
        seek_layout = QVBoxLayout(seek_group)
        
        # URL input and buttons
        url_layout = QHBoxLayout()
        url_layout.addWidget(QLabel("Target URL:"))
        self.url_input = QLineEdit()
        self.url_input.setPlaceholderText("https://target.com or paste link here")
        url_layout.addWidget(self.url_input)
        
        # Main SEEK button (prominent)
        self.seek_button = QPushButton("âš¡ SEEK EXPLOITS")
        self.seek_button.setStyleSheet("""
            QPushButton {
                background-color: #ff4444;
                color: white;
                font-weight: bold;
                font-size: 12px;
                padding: 8px;
                border-radius: 4px;
            }
            QPushButton:hover {
                background-color: #ff2222;
            }
            QPushButton:pressed {
                background-color: #cc0000;
            }
        """)
        self.seek_button.clicked.connect(self._start_seek)
        self.seek_button.setCursor(Qt.CursorShape.PointingHandCursor)
        url_layout.addWidget(self.seek_button)
        
        # AI Vulnerability Testing button
        self.ai_test_button = QPushButton("ðŸ¤– AI TEST")
        self.ai_test_button.setStyleSheet("""
            QPushButton {
                background-color: #9C27B0;
                color: white;
                font-weight: bold;
                font-size: 12px;
                padding: 8px;
                border-radius: 4px;
            }
            QPushButton:hover {
                background-color: #7B1FA2;
            }
            QPushButton:pressed {
                background-color: #6A1B9A;
            }
        """)
        self.ai_test_button.clicked.connect(self._start_ai_test)
        self.ai_test_button.setCursor(Qt.CursorShape.PointingHandCursor)
        self.ai_test_button.setEnabled(HAS_AI_TESTER)
        self.ai_test_button.setToolTip("Run AI-powered vulnerability tests on authorized website")
        url_layout.addWidget(self.ai_test_button)
        
        # Auto-attempt checkbox
        self.auto_attempt_check = QCheckBox("Auto-Attempt")
        self.auto_attempt_check.setChecked(True)
        self.auto_attempt_check.setToolTip("Automatically attempt discovered exploits")
        url_layout.addWidget(self.auto_attempt_check)
        
        seek_layout.addLayout(url_layout)
        
        # Search options
        options_layout = QHBoxLayout()
        options_layout.addWidget(QLabel("Severity Filter:"))
        self.severity_filter = QComboBox()
        self.severity_filter.addItems(["All", "Critical", "High", "Medium", "Low"])
        options_layout.addWidget(self.severity_filter)
        
        options_layout.addWidget(QLabel("Max Attempts:"))
        self.max_attempts = QSpinBox()
        self.max_attempts.setValue(10)
        self.max_attempts.setRange(1, 100)
        options_layout.addWidget(self.max_attempts)
        
        options_layout.addWidget(QLabel("Timeout (sec):"))
        self.timeout_spin = QSpinBox()
        self.timeout_spin.setValue(30)
        self.timeout_spin.setRange(5, 300)
        options_layout.addWidget(self.timeout_spin)
        
        options_layout.addStretch()
        seek_layout.addLayout(options_layout)
        
        # Progress bar
        self.progress_bar = QProgressBar()
        self.progress_bar.setVisible(False)
        seek_layout.addWidget(self.progress_bar)
        
        # Status label
        self.status_label = QLabel("Ready")
        self.status_label.setStyleSheet("color: #4CAF50; font-weight: bold;")
        seek_layout.addWidget(self.status_label)
        
        layout.addWidget(seek_group)
        
        # ===== RESULTS TABS =====
        results_tabs = QTabWidget()
        
        # TAB 1: Search Results
        results_widget = QWidget()
        results_layout = QVBoxLayout(results_widget)
        
        self.results_table = QTableWidget()
        self.results_table.setColumnCount(6)
        self.results_table.setHorizontalHeaderLabels([
            "Exploit Type", "Severity", "Status", "Payload", "Description", "Source"
        ])
        self.results_table.setColumnWidth(0, 150)
        self.results_table.setColumnWidth(1, 80)
        self.results_table.setColumnWidth(2, 100)
        self.results_table.setColumnWidth(3, 150)
        self.results_table.setColumnWidth(4, 200)
        self.results_table.setColumnWidth(5, 100)
        results_layout.addWidget(self.results_table)
        results_tabs.addTab(results_widget, "Search Results")
        
        # TAB 2: Detailed Output
        self.details_output = QTextEdit()
        self.details_output.setReadOnly(True)
        self.details_output.setFont(QFont("Courier", 9))
        results_tabs.addTab(self.details_output, "Details")
        
        # TAB 3: Network Sharing
        network_widget = QWidget()
        network_layout = QVBoxLayout(network_widget)
        
        self.stats_label = QLabel("Network Stats: Loading...")
        network_layout.addWidget(self.stats_label)
        
        button_layout = QHBoxLayout()
        share_btn = QPushButton("ðŸ“¤ Share Results")
        share_btn.clicked.connect(self._share_to_network)
        button_layout.addWidget(share_btn)
        
        export_btn = QPushButton("ðŸ’¾ Export Results")
        export_btn.clicked.connect(self._export_results)
        button_layout.addWidget(export_btn)
        
        clear_btn = QPushButton("ðŸ—‘ï¸ Clear Results")
        clear_btn.clicked.connect(self._clear_results)
        button_layout.addWidget(clear_btn)
        
        network_layout.addLayout(button_layout)
        
        self.network_list = QListWidget()
        network_layout.addWidget(QLabel("Network Exploits:"))
        network_layout.addWidget(self.network_list)
        
        results_tabs.addTab(network_widget, "Network")
        
        layout.addWidget(results_tabs)
        
        self.setLayout(layout)
    
    def _start_seek(self):
        """Start exploit seeking"""
        target = self.url_input.text().strip()
        
        if not target:
            QMessageBox.warning(self, "Input Required", "Please enter a target URL")
            return
        
        if not target.startswith(('http://', 'https://')):
            target = f'https://{target}'
        
        self.seek_button.setEnabled(False)
        self.seek_button.setText("âš¡ SEEKING...")
        self.progress_bar.setVisible(True)
        self.status_label.setText("ðŸ” Seeking exploits...")
        self.status_label.setStyleSheet("color: #2196F3; font-weight: bold;")
        
        # Use unified seeker if available
        if self.unified_seeker:
            self.seek_worker = UnifiedSeekWorker(self.unified_seeker, target)
            self.seek_worker.enumeration_progress.connect(self._on_enumeration_progress)
        else:
            self.seek_worker = SeekWorker(self.exploit_seeker, target)
        
        self.seek_worker.finished.connect(self._on_seek_finished)
        self.seek_worker.progress.connect(self._on_seek_progress)
        self.seek_worker.error.connect(self._on_seek_error)
        self.seek_worker.start()
    
    def _start_ai_test(self):
        """Start AI vulnerability testing"""
        if not self.ai_tester:
            QMessageBox.warning(self, "Not Available", "AI Vulnerability Tester not initialized")
            return
        
        target_url = self.url_input.text().strip()
        if not target_url:
            QMessageBox.warning(self, "Input Required", "Please enter a target URL")
            return
        
        # Ensure URL has protocol
        if not target_url.startswith(('http://', 'https://')):
            target_url = f'https://{target_url}'
            self.url_input.setText(target_url)
        
        # Disable button and show progress
        self.ai_test_button.setEnabled(False)
        self.ai_test_button.setText("ðŸ¤– TESTING...")
        self.progress_bar.setVisible(True)
        self.progress_bar.setMaximum(0)
        self.status_label.setText("ðŸ¤– Running AI vulnerability tests...")
        self.status_label.setStyleSheet("color: #9C27B0; font-weight: bold;")
        
        # Create and start worker
        self.ai_worker = AIVulnerabilityWorker(
            self.ai_tester,
            target_url,
            test_categories=['injection', 'authentication', 'configuration', 'headers']
        )
        self.ai_worker.finished.connect(self._on_ai_test_finished)
        self.ai_worker.progress.connect(self._on_ai_test_progress)
        self.ai_worker.error.connect(self._on_ai_test_error)
        self.ai_worker.start()
    
    def _on_seek_finished(self, result: dict):
        """Handle seek completion"""
        try:
            self.current_search_results = result
            
            # Update UI
            self.seek_button.setEnabled(True)
            self.seek_button.setText("âš¡ SEEK EXPLOITS")
            self.progress_bar.setVisible(False)
            
            attempts = result.get('attempts', [])
            successful = sum(1 for a in attempts if a.get('success'))
            
            if result['status'] == 'exploited':
                self.status_label.setText(f"âœ… SUCCESS! Exploited with {successful} successful attempts")
                self.status_label.setStyleSheet("color: #4CAF50; font-weight: bold;")
            elif attempts:
                self.status_label.setText(f"âš ï¸  Found {len(attempts)} exploits, {successful} successful")
                self.status_label.setStyleSheet("color: #ff9800; font-weight: bold;")
            else:
                self.status_label.setText("âŒ No exploits found for target")
                self.status_label.setStyleSheet("color: #f44336; font-weight: bold;")
            
            # Display results
            self._display_results(result)
        except Exception as e:
            self.status_label.setText(f"Error: {str(e)}")
            self.status_label.setStyleSheet("color: #f44336; font-weight: bold;")
    
    def _on_ai_test_finished(self, result: dict):
        """Handle AI test completion"""
        try:
            self.current_ai_results = result
            
            # Update UI
            self.ai_test_button.setEnabled(True)
            self.ai_test_button.setText("ðŸ¤– AI TEST")
            self.progress_bar.setVisible(False)
            
            vuln_count = result.get('vulnerabilities_found', 0)
            total_tests = result.get('total_tests', 0)
            
            if vuln_count > 0:
                self.status_label.setText(
                    f"ðŸš¨ AI TEST COMPLETE: {vuln_count} vulnerabilities in {total_tests} tests"
                )
                self.status_label.setStyleSheet("color: #ff5722; font-weight: bold;")
            else:
                self.status_label.setText(
                    f"âœ… AI TEST COMPLETE: No vulnerabilities found ({total_tests} tests)"
                )
                self.status_label.setStyleSheet("color: #4CAF50; font-weight: bold;")
            
            # Display AI test results
            self._display_ai_results(result)
            
        except Exception as e:
            self.status_label.setText(f"Error: {str(e)}")
            self.status_label.setStyleSheet("color: #f44336; font-weight: bold;")
    
    def _on_seek_progress(self, message: str):
        """Handle progress update"""
        self.status_label.setText(message)
    
    def _on_ai_test_progress(self, message: str):
        """Handle AI test progress"""
        self.status_label.setText(message)
    
    def _on_enumeration_progress(self, message: str):
        """Handle enumeration progress"""
        current = self.details_output.toPlainText()
        if current and not current.endswith('\n\n'):
            current += '\n'
        self.details_output.setText(current + message)
        self.details_output.verticalScrollBar().setValue(
            self.details_output.verticalScrollBar().maximum()
        )
    
    def _on_seek_error(self, error: str):
        """Handle seek error"""
        self.seek_button.setEnabled(True)
        self.seek_button.setText("âš¡ SEEK EXPLOITS")
        self.progress_bar.setVisible(False)
        self.status_label.setText(f"âŒ Error: {error}")
        self.status_label.setStyleSheet("color: #f44336; font-weight: bold;")
        QMessageBox.critical(self, "Seek Error", error)
    
    def _on_ai_test_error(self, error: str):
        """Handle AI test error"""
        self.ai_test_button.setEnabled(True)
        self.ai_test_button.setText("ðŸ¤– AI TEST")
        self.progress_bar.setVisible(False)
        self.status_label.setText(f"âŒ AI Test Error: {error}")
        self.status_label.setStyleSheet("color: #f44336; font-weight: bold;")
        QMessageBox.critical(self, "AI Test Error", error)
    
    def _display_results(self, result: dict):
        """Display search results in table"""
        try:
            self.results_table.setRowCount(0)
            
            attempts = result.get('attempts', [])
            for attempt in attempts:
                row = self.results_table.rowCount()
                self.results_table.insertRow(row)
                
                exploit_type = attempt.get('exploit_type', 'Unknown')
                success = "âœ… Success" if attempt.get('success') else "âŒ Failed"
                severity = attempt.get('severity', 'Medium')
                source = attempt.get('source', 'Unknown')
                
                items = [
                    exploit_type,
                    severity,
                    success,
                    attempt.get('payload', '')[:50],
                    attempt.get('description', '')[:50],
                    source
                ]
                
                for col, item in enumerate(items):
                    cell = QTableWidgetItem(str(item))
                    if success == "âœ… Success":
                        cell.setBackground(QColor(100, 255, 100))
                    self.results_table.setItem(row, col, cell)
            
            # Detailed output
            details = f"""
EXPLOIT SEEK RESULTS
Target: {result.get('target', 'Unknown')}
Status: {result.get('status', 'Unknown').upper()}
Total Exploits Found: {len(attempts)}
Timestamp: {time.ctime(result.get('timestamp', time.time()))}

SUMMARY:
Total: {len(attempts)}
Successful: {sum(1 for a in attempts if a.get('success'))}
Failed: {sum(1 for a in attempts if not a.get('success'))}
"""
            
            for i, attempt in enumerate(attempts, 1):
                details += f"""
EXPLOIT #{i}
Type: {attempt.get('exploit_type', 'Unknown')}
Severity: {attempt.get('severity', 'Unknown')}
Status: {'âœ… SUCCESS' if attempt.get('success') else 'â„¹ï¸ INFO'}
Payload: {attempt.get('payload', 'N/A')}
Description: {attempt.get('description', 'N/A')}
Source: {attempt.get('source', 'Unknown')}
"""
            
            self.details_output.setText(details)
        except Exception as e:
            logger.error(f"Display results error: {e}")
    
    def _display_ai_results(self, result: dict):
        """Display AI test results"""
        try:
            self.results_table.setRowCount(0)
            
            test_results = result.get('results', [])
            for test_result in test_results:
                if test_result.get('vulnerable'):
                    row = self.results_table.rowCount()
                    self.results_table.insertRow(row)
                    
                    items = [
                        test_result.get('test_name', 'Unknown'),
                        test_result.get('test_id', ''),
                        "ðŸš¨ VULNERABLE",
                        f"Code: {test_result.get('response_code', 'N/A')}",
                        test_result.get('evidence', 'N/A')[:50],
                        test_result.get('confidence', 'N/A')
                    ]
                    
                    for col, item in enumerate(items):
                        cell = QTableWidgetItem(str(item))
                        cell.setBackground(QColor(255, 100, 100))
                        self.results_table.setItem(row, col, cell)
            
            # Detailed output
            details = f"""
AI VULNERABILITY TEST RESULTS
Target: {result.get('target', 'Unknown')}
Timestamp: {time.ctime(result.get('timestamp', time.time()))}
Status: {result.get('status', 'Unknown').upper()}

SUMMARY:
Total Tests: {result.get('total_tests', 0)}
Vulnerabilities Found: {result.get('vulnerabilities_found', 0)}
Success Rate: {result.get('success_rate', 'N/A')}
Avg Response Time: {result.get('avg_response_time', 'N/A')}

VULNERABLE TESTS:
"""
            
            for test in test_results:
                if test.get('vulnerable'):
                    details += f"""
Test: {test.get('test_name', 'Unknown')}
ID: {test.get('test_id', 'N/A')}
Confidence: {test.get('confidence', 'N/A')}
Response Code: {test.get('response_code', 'N/A')}
Evidence: {test.get('evidence', 'N/A')}
Payload: {test.get('payload', 'N/A')[:100]}
"""
            
            if self.ai_tester:
                remediation = self.ai_tester.get_remediation_recommendations()
                details += f"""

REMEDIATION RECOMMENDATIONS:

CRITICAL ISSUES:
"""
                for rec in remediation.get('critical', []):
                    details += f"\n{rec['vulnerability']}\nFix: {rec['fix']}\n"
                
                details += """
HIGH PRIORITY:
"""
                for rec in remediation.get('high', []):
                    details += f"\n{rec['vulnerability']}\nFix: {rec['fix']}\n"
            
            details += f"""

AI Testing Complete - {time.ctime()}
For authorized testing only - ensure proper authorization
"""
            
            self.details_output.setText(details)
            
        except Exception as e:
            logger.error(f"Display AI results error: {e}")
    
    def _refresh_shared_exploits(self):
        """Refresh exploits from network"""
        if not self.exploit_sharer:
            return
        
        stats = self.exploit_sharer.get_network_statistics()
        
        self.stats_label.setText(
            f"Network Stats: {stats['total_exploits']} exploits, "
            f"{stats['critical_count']} critical, "
            f"{stats['high_count']} high"
        )
        
        self.network_list.clear()
        
        all_exploits = (
            self.exploit_sharer.registry.get_all_exploits() +
            list(self.exploit_sharer.received_exploits.values())
        )
        
        for exploit in sorted(all_exploits, 
                             key=lambda e: {'Critical': 0, 'High': 1, 'Medium': 2, 'Low': 3}.get(e.severity, 4)):
            item_text = f"[{exploit.severity}] {exploit.exploit_type} - {exploit.target_url}"
            item = QListWidgetItem(item_text)
            
            if exploit.severity == 'Critical':
                item.setBackground(QColor(255, 100, 100))
            elif exploit.severity == 'High':
                item.setBackground(QColor(255, 165, 0))
            
            self.network_list.addItem(item)
    
    def _export_results(self):
        """Export current results"""
        if not self.current_search_results:
            QMessageBox.warning(self, "No Results", "No search results to export")
            return
        
        filename = self.exploit_sharer.export_exploits()
        QMessageBox.information(self, "Exported", f"Results exported to {filename}")
    
    def _share_to_network(self):
        """Share current results to P2P network"""
        if not self.exploit_sharer.network_node:
            QMessageBox.warning(self, "Network Unavailable", 
                              "P2P network not configured. Enable Network Sharing first.")
            return
        
        attempts = self.current_search_results.get('attempts', [])
        if not attempts:
            QMessageBox.warning(self, "No Results", "No exploits to share")
            return
        
        count = 0
        for attempt in attempts:
            if attempt.get('success'):
                exploit = ExploitFinding(
                    exploit_id=f"{attempt['exploit_id']}_{int(time.time())}",
                    target_url=self.current_search_results.get('target', ''),
                    exploit_type=attempt.get('exploit_type', ''),
                    severity='Critical' if attempt.get('success') else 'High',
                    payload=attempt.get('payload', ''),
                    description=f"Successful exploit discovered via seek",
                    timestamp=time.time(),
                    instance_id=self.exploit_sharer.instance_id,
                    success=True
                )
                self.exploit_sharer.register_exploit(exploit)
                count += 1
        
        QMessageBox.information(self, "Shared", f"{count} exploits shared to network")
    
    def _clear_results(self):
        """Clear results"""
        self.results_table.setRowCount(0)
        self.details_output.clear()
        self.url_input.clear()
        self.current_search_results = {}
        self.current_ai_results = {}
        self.status_label.setText("Ready")
        self.status_label.setStyleSheet("color: #4CAF50; font-weight: bold;")


def create_exploit_seek_tab(parent=None, exploit_sharer: P2PExploitSharer = None, hades_ai=None) -> ExploitSeekTab:
    """Factory function to create exploit seek tab with all available knowledge sources"""
    return ExploitSeekTab(parent, exploit_sharer, hades_ai)
