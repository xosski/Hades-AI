"""
Exploit Seek & Share Tab for HadesAI
Provides UI for P2P exploit searching and automatic exploitation
"""

from PyQt6.QtWidgets import (
    QWidget, QVBoxLayout, QHBoxLayout, QGroupBox, QLabel, QPushButton,
    QLineEdit, QTextEdit, QTableWidget, QTableWidgetItem, QProgressBar,
    QComboBox, QCheckBox, QSpinBox, QTabWidget, QMessageBox, QListWidget,
    QListWidgetItem, QSplitter, QStatusBar, QFormLayout
)
from PyQt6.QtCore import Qt, QThread, pyqtSignal, QTimer
from PyQt6.QtGui import QFont, QColor, QIcon
import json
import time
import logging
from typing import Optional, Callable, Dict, List
from p2p_exploit_sharing import (
    P2PExploitSharer, ExploitSeeker, ExploitFinding
)

logger = logging.getLogger("ExploitSeekTab")

try:
    from comprehensive_exploit_seeker import UnifiedExploitKnowledge
    HAS_UNIFIED_SEEKER = True
except ImportError:
    UnifiedExploitKnowledge = None
    HAS_UNIFIED_SEEKER = False


class SeekWorker(QThread):
    """Background worker for exploit seeking"""
    finished = pyqtSignal(dict)
    progress = pyqtSignal(str)
    error = pyqtSignal(str)
    
    def __init__(self, seeker: ExploitSeeker, target_url: str):
        super().__init__()
        self.seeker = seeker
        self.target_url = target_url
        self.setObjectName("SeekWorker")
    
    def run(self):
        try:
            self.progress.emit(f"Seeking exploits for {self.target_url}...")
            result = self.seeker.seek_and_attempt(
                self.target_url,
                callback=self._progress_callback
            )
            if result:
                self.finished.emit(result)
            else:
                self.error.emit("No result returned from seek")
        except Exception as e:
            self.error.emit(str(e))
    
    def _progress_callback(self, result: dict):
        if result:
            self.progress.emit(f"Exploit attempts: {len(result.get('attempts', []))}")


class UnifiedSeekWorker(QThread):
    """Background worker for unified exploit seeking from all sources"""
    finished = pyqtSignal(dict)
    progress = pyqtSignal(str)
    enumeration_progress = pyqtSignal(str)  # Per-source progress
    error = pyqtSignal(str)
    
    def __init__(self, unified_seeker, target_url: str):
        super().__init__()
        self.unified_seeker = unified_seeker
        self.target_url = target_url
        self.setObjectName("UnifiedSeekWorker")
    
    def run(self):
        try:
            self.progress.emit("Initiating comprehensive exploit enumeration...")
            self.enumeration_progress.emit("Searching 7 knowledge sources...")
            
            # Get exploits from all sources
            exploits = self.unified_seeker.seek_all_exploits(self.target_url)
            
            # Get source statistics
            source_stats = self.unified_seeker.get_source_stats(exploits)
            source_info = "\n".join([f"  {src}: {cnt}" for src, cnt in source_stats.items()])
            
            self.progress.emit(f"Enumeration complete: {len(exploits)} total exploits found")
            self.enumeration_progress.emit(f"Source breakdown:\n{source_info}")
            
            # Convert exploits to attempts format (dicts with all details)
            attempts = []
            for i, exploit in enumerate(exploits, 1):
                attempt = {
                    'exploit_id': exploit.get('id', f'exploit_{i}'),
                    'exploit_type': exploit.get('type', 'Unknown'),
                    'severity': exploit.get('severity', 'Medium'),
                    'payload': exploit.get('payload', ''),
                    'description': exploit.get('description', ''),
                    'success': exploit.get('success', False),
                    'confidence': exploit.get('confidence', 0.5),
                    'source': exploit.get('source', 'Unknown'),
                    'impact': exploit.get('impact', ''),
                    'remediation': exploit.get('remediation', ''),
                    'timestamp': exploit.get('timestamp', time.time())
                }
                attempts.append(attempt)
            
            # Prepare result
            result = {
                'target': self.target_url,
                'status': 'completed' if len(attempts) > 0 else 'no_exploits_found',
                'attempts': attempts,
                'timestamp': time.time(),
                'total_exploits': len(attempts),
                'sources': source_stats,
                'enumeration_complete': True
            }
            
            self.finished.emit(result)
        except Exception as e:
            import traceback
            error_detail = f"Comprehensive seek error: {str(e)}\n{traceback.format_exc()}"
            logger.error(error_detail)
            self.error.emit(error_detail)


class ExploitSeekTab(QWidget):
    """Tab for exploit seeking and P2P sharing"""
    
    def __init__(self, parent=None, exploit_sharer: P2PExploitSharer = None, hades_ai=None):
        super().__init__(parent)
        self.exploit_sharer = exploit_sharer or P2PExploitSharer()
        self.hades_ai = hades_ai
        self.exploit_seeker = ExploitSeeker(self.exploit_sharer)
        
        # Use unified seeker if available
        self.unified_seeker = None
        if HAS_UNIFIED_SEEKER and hades_ai:
            self.unified_seeker = UnifiedExploitKnowledge(hades_ai, exploit_sharer)
        
        self.seek_worker = None
        self.current_search_results = {}
        self.init_ui()
        
        # Auto-refresh shared exploits
        self.refresh_timer = QTimer()
        self.refresh_timer.timeout.connect(self._refresh_shared_exploits)
        self.refresh_timer.start(5000)  # Every 5 seconds
    
    def closeEvent(self, event):
        """Cleanup threads on close"""
        self.refresh_timer.stop()
        if self.seek_worker and self.seek_worker.isRunning():
            self.seek_worker.quit()
            self.seek_worker.wait()
        super().closeEvent(event)
    
    def init_ui(self):
        layout = QVBoxLayout(self)
        
        # ===== SEEK SECTION =====
        seek_group = QGroupBox("ðŸ” Exploit Seeker")
        seek_layout = QVBoxLayout(seek_group)
        
        # URL input and buttons
        url_layout = QHBoxLayout()
        url_layout.addWidget(QLabel("Target URL:"))
        self.url_input = QLineEdit()
        self.url_input.setPlaceholderText("https://target.com or paste link here")
        url_layout.addWidget(self.url_input)
        
        # Main SEEK button (prominent)
        self.seek_button = QPushButton("âš¡ SEEK EXPLOITS")
        self.seek_button.setStyleSheet("""
            QPushButton {
                background-color: #ff4444;
                color: white;
                font-weight: bold;
                font-size: 12px;
                padding: 8px;
                border-radius: 4px;
            }
            QPushButton:hover {
                background-color: #ff2222;
            }
            QPushButton:pressed {
                background-color: #cc0000;
            }
        """)
        self.seek_button.clicked.connect(self._start_seek)
        self.seek_button.setCursor(Qt.CursorShape.PointingHandCursor)
        url_layout.addWidget(self.seek_button)
        
        # Auto-attempt checkbox
        self.auto_attempt_check = QCheckBox("Auto-Attempt")
        self.auto_attempt_check.setChecked(True)
        self.auto_attempt_check.setToolTip("Automatically attempt discovered exploits")
        url_layout.addWidget(self.auto_attempt_check)
        
        seek_layout.addLayout(url_layout)
        
        # Search options
        options_layout = QHBoxLayout()
        options_layout.addWidget(QLabel("Severity Filter:"))
        self.severity_filter = QComboBox()
        self.severity_filter.addItems(["All", "Critical", "High", "Medium", "Low"])
        options_layout.addWidget(self.severity_filter)
        
        options_layout.addWidget(QLabel("Max Attempts:"))
        self.max_attempts = QSpinBox()
        self.max_attempts.setValue(10)
        self.max_attempts.setRange(1, 100)
        options_layout.addWidget(self.max_attempts)
        
        options_layout.addWidget(QLabel("Timeout (sec):"))
        self.timeout_spin = QSpinBox()
        self.timeout_spin.setValue(30)
        self.timeout_spin.setRange(5, 300)
        options_layout.addWidget(self.timeout_spin)
        
        options_layout.addStretch()
        seek_layout.addLayout(options_layout)
        
        # Progress bar
        self.progress_bar = QProgressBar()
        self.progress_bar.setVisible(False)
        seek_layout.addWidget(self.progress_bar)
        
        # Status label
        self.status_label = QLabel("Ready")
        self.status_label.setStyleSheet("color: #4CAF50; font-weight: bold;")
        seek_layout.addWidget(self.status_label)
        
        layout.addWidget(seek_group)
        
        # ===== RESULTS TABS =====
        results_tabs = QTabWidget()
        
        # TAB 1: Search Results
        results_widget = QWidget()
        results_layout = QVBoxLayout(results_widget)
        
        self.results_table = QTableWidget()
        self.results_table.setColumnCount(6)
        self.results_table.setHorizontalHeaderLabels([
            "Exploit Type", "Severity", "Status", "Payload", "Description", "Source"
        ])
        self.results_table.setColumnWidth(0, 150)
        self.results_table.setColumnWidth(1, 80)
        self.results_table.setColumnWidth(2, 80)
        self.results_table.setColumnWidth(3, 200)
        self.results_table.setColumnWidth(4, 300)
        self.results_table.setColumnWidth(5, 100)
        results_layout.addWidget(QLabel("Discovered Exploits:"))
        results_layout.addWidget(self.results_table)
        
        results_tabs.addTab(results_widget, "Search Results")
        
        # TAB 2: Shared Network Exploits
        network_widget = QWidget()
        network_layout = QVBoxLayout(network_widget)
        
        self.network_list = QListWidget()
        network_layout.addWidget(QLabel("Exploits from Network Peers:"))
        network_layout.addWidget(self.network_list)
        
        # Network stats
        stats_layout = QHBoxLayout()
        self.stats_label = QLabel("Network Stats: 0 exploits, 0 critical")
        stats_layout.addWidget(self.stats_label)
        stats_layout.addStretch()
        
        refresh_btn = QPushButton("ðŸ”„ Refresh")
        refresh_btn.clicked.connect(self._refresh_shared_exploits)
        stats_layout.addWidget(refresh_btn)
        
        network_layout.addLayout(stats_layout)
        
        results_tabs.addTab(network_widget, "Network Shared Exploits")
        
        # TAB 3: Detailed Results
        details_widget = QWidget()
        details_layout = QVBoxLayout(details_widget)
        
        self.details_output = QTextEdit()
        self.details_output.setReadOnly(True)
        details_layout.addWidget(self.details_output)
        
        results_tabs.addTab(details_widget, "Detailed Analysis")
        
        layout.addWidget(results_tabs)
        
        # ===== ACTION BUTTONS =====
        action_layout = QHBoxLayout()
        
        export_btn = QPushButton("ðŸ“¤ Export Results")
        export_btn.clicked.connect(self._export_results)
        action_layout.addWidget(export_btn)
        
        share_btn = QPushButton("ðŸ”— Share to Network")
        share_btn.clicked.connect(self._share_to_network)
        action_layout.addWidget(share_btn)
        
        action_layout.addStretch()
        
        clear_btn = QPushButton("Clear")
        clear_btn.clicked.connect(self._clear_results)
        action_layout.addWidget(clear_btn)
        
        layout.addLayout(action_layout)
    
    def _start_seek(self):
        """Start seeking exploits for target"""
        target_url = self.url_input.text().strip()
        
        if not target_url:
            QMessageBox.warning(self, "Input Error", "Please enter a target URL")
            return
        
        # Ensure URL has protocol
        if not target_url.startswith(('http://', 'https://')):
            target_url = 'https://' + target_url
        
        self.url_input.setText(target_url)
        
        # Disable button during search
        self.seek_button.setEnabled(False)
        self.seek_button.setText("â³ SEEKING...")
        
        # Show progress
        self.progress_bar.setVisible(True)
        self.progress_bar.setValue(0)
        self.status_label.setText(f"Seeking exploits from ALL knowledge sources for {target_url}...")
        self.status_label.setStyleSheet("color: #ff9800; font-weight: bold;")
        
        # Start worker thread
        # Use unified seeker if available, otherwise fallback
        if self.unified_seeker:
            self.seek_worker = UnifiedSeekWorker(self.unified_seeker, target_url)
            # Connect enumeration progress for detailed feedback
            self.seek_worker.enumeration_progress.connect(self._on_enumeration_progress)
        else:
            self.seek_worker = SeekWorker(self.exploit_seeker, target_url)
        
        self.seek_worker.finished.connect(self._on_seek_finished)
        self.seek_worker.progress.connect(self._on_seek_progress)
        self.seek_worker.error.connect(self._on_seek_error)
        self.seek_worker.start()
    
    def _on_seek_finished(self, result: dict):
        """Handle seek completion"""
        try:
            self.current_search_results = result
            
            # Update UI
            self.seek_button.setEnabled(True)
            self.seek_button.setText("âš¡ SEEK EXPLOITS")
            self.progress_bar.setVisible(False)
            
            attempts = result.get('attempts', [])
            successful = sum(1 for a in attempts if a.get('success'))
            
            if result['status'] == 'exploited':
                self.status_label.setText(f"âœ… SUCCESS! Exploited with {successful} successful attempts")
                self.status_label.setStyleSheet("color: #4CAF50; font-weight: bold;")
            elif attempts:
                self.status_label.setText(f"âš ï¸  Found {len(attempts)} exploits, {successful} successful")
                self.status_label.setStyleSheet("color: #ff9800; font-weight: bold;")
            else:
                self.status_label.setText("âŒ No exploits found for target")
                self.status_label.setStyleSheet("color: #f44336; font-weight: bold;")
            
            # Display results
            self._display_results(result)
        except Exception as e:
            self.status_label.setText(f"Error: {str(e)}")
            self.status_label.setStyleSheet("color: #f44336; font-weight: bold;")
    
    def _on_seek_progress(self, message: str):
        """Handle progress update"""
        self.status_label.setText(message)
    
    def _on_enumeration_progress(self, message: str):
        """Handle enumeration source progress"""
        # Append to details output for visibility
        current = self.details_output.toPlainText()
        if current and not current.endswith('\n\n'):
            current += '\n'
        self.details_output.setText(current + message)
        # Scroll to bottom
        self.details_output.verticalScrollBar().setValue(
            self.details_output.verticalScrollBar().maximum()
        )
    
    def _on_seek_error(self, error: str):
        """Handle seek error"""
        self.seek_button.setEnabled(True)
        self.seek_button.setText("âš¡ SEEK EXPLOITS")
        self.progress_bar.setVisible(False)
        self.status_label.setText(f"âŒ Error: {error}")
        self.status_label.setStyleSheet("color: #f44336; font-weight: bold;")
        QMessageBox.critical(self, "Seek Error", error)
    
    def _display_results(self, result: dict):
        """Display search results in table (thread-safe)"""
        try:
            self.results_table.setRowCount(0)
            
            attempts = result.get('attempts', [])
            for attempt in attempts:
                row = self.results_table.rowCount()
                self.results_table.insertRow(row)
                
                exploit_type = attempt.get('exploit_type', 'Unknown')
                success = "âœ… Success" if attempt.get('success') else "âŒ Failed"
                severity = attempt.get('severity', 'Medium')
                source = attempt.get('source', 'Unknown')
                
                items = [
                    exploit_type,
                    severity,
                    success,
                    attempt.get('payload', '')[:50],
                    attempt.get('description', '')[:50],
                    source
                ]
                
                for col, item in enumerate(items):
                    cell = QTableWidgetItem(str(item))
                    if success == "âœ… Success":
                        cell.setBackground(QColor(100, 255, 100))
                    self.results_table.setItem(row, col, cell)
            
            # Detailed output with comprehensive information
            details = f"""
â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
â•‘                      EXPLOIT SEEK RESULTS - DETAILED                        â•‘
â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

Target URL: {result.get('target', 'Unknown')}
Overall Status: {result.get('status', 'Unknown').upper()}
Total Exploits Found: {len(attempts)}
Enumeration Timestamp: {time.ctime(result.get('timestamp', time.time()))}

â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

SUMMARY STATISTICS:
â”œâ”€ Total Exploits: {len(attempts)}
â”œâ”€ Successful: {sum(1 for a in attempts if a.get('success'))} âœ…
â”œâ”€ Information Only: {sum(1 for a in attempts if not a.get('success'))} â„¹ï¸
â””â”€ Average Confidence: {sum(a.get('confidence', 0) for a in attempts) / max(1, len(attempts)):.1%}

SOURCE BREAKDOWN:
"""
            # Add source stats
            sources = result.get('sources', {})
            for source_name, count in sorted(sources.items(), key=lambda x: x[1], reverse=True):
                if count > 0:
                    details += f"â”œâ”€ {source_name}: {count}\n"
            details += f"""
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

DETAILED EXPLOIT INFORMATION:
"""
            
            for i, attempt in enumerate(attempts, 1):
                details += f"""
â”Œâ”€ EXPLOIT #{i}
â”‚
â”œâ”€ Type: {attempt.get('exploit_type', 'Unknown')}
â”œâ”€ Severity: {attempt.get('severity', 'Unknown')}
â”œâ”€ Status: {'âœ… SUCCESSFUL' if attempt.get('success') else 'â„¹ï¸ INFORMATIONAL'}
â”œâ”€ Confidence: {attempt.get('confidence', 0):.0%}
â”œâ”€ Source: {attempt.get('source', 'Unknown')}
â”‚
â”œâ”€ Description:
â”‚  {attempt.get('description', 'N/A')}
â”‚
â”œâ”€ Payload Details:
â”‚  {attempt.get('payload', 'N/A')[:200] if attempt.get('payload') else 'N/A'}
â”‚
"""
                if attempt.get('impact'):
                    details += f"â”œâ”€ Impact: {attempt.get('impact')}\n"
                if attempt.get('remediation'):
                    details += f"â”œâ”€ Remediation: {attempt.get('remediation')}\n"
                details += "â”‚\n"
            
            details += f"""
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

WHAT THIS MEANS:
âœ… Successful exploits: Vulnerabilities we can verify can be exploited
â„¹ï¸  Informational: Potential vulnerabilities discovered but need further testing
ðŸ” Severity levels: Critical > High > Medium > Low

NEXT STEPS:
1. Review each exploit type for potential impact
2. Verify successful exploits against target environment
3. Test informational findings on authorized systems
4. Prioritize remediation by severity and confidence
5. Document findings and create mitigation strategies

â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
"""
            
            self.details_output.setText(details)
        except Exception as e:
            import traceback
            self.status_label.setText(f"Error displaying results: {str(e)}")
            self.status_label.setStyleSheet("color: #f44336; font-weight: bold;")
            logger.error(f"Display results error: {traceback.format_exc()}")
    
    def _refresh_shared_exploits(self):
        """Refresh exploits from network"""
        if not self.exploit_sharer:
            return
        
        stats = self.exploit_sharer.get_network_statistics()
        
        # Update stats label
        self.stats_label.setText(
            f"Network Stats: {stats['total_exploits']} exploits, "
            f"{stats['critical_count']} critical, "
            f"{stats['high_count']} high"
        )
        
        # Update network list
        self.network_list.clear()
        
        all_exploits = (
            self.exploit_sharer.registry.get_all_exploits() +
            list(self.exploit_sharer.received_exploits.values())
        )
        
        for exploit in sorted(all_exploits, 
                             key=lambda e: {'Critical': 0, 'High': 1, 'Medium': 2, 'Low': 3}.get(e.severity, 4)):
            item_text = f"[{exploit.severity}] {exploit.exploit_type} - {exploit.target_url}"
            item = QListWidgetItem(item_text)
            
            # Color by severity
            if exploit.severity == 'Critical':
                item.setBackground(QColor(255, 100, 100))
            elif exploit.severity == 'High':
                item.setBackground(QColor(255, 165, 0))
            
            self.network_list.addItem(item)
    
    def _export_results(self):
        """Export current results"""
        if not self.current_search_results:
            QMessageBox.warning(self, "No Results", "No search results to export")
            return
        
        filename = self.exploit_sharer.export_exploits()
        QMessageBox.information(self, "Exported", f"Results exported to {filename}")
    
    def _share_to_network(self):
        """Share current results to P2P network"""
        if not self.exploit_sharer.network_node:
            QMessageBox.warning(self, "Network Unavailable", 
                              "P2P network not configured. Enable Network Sharing first.")
            return
        
        attempts = self.current_search_results.get('attempts', [])
        if not attempts:
            QMessageBox.warning(self, "No Results", "No exploits to share")
            return
        
        count = 0
        for attempt in attempts:
            if attempt.get('success'):
                exploit = ExploitFinding(
                    exploit_id=f"{attempt['exploit_id']}_{int(time.time())}",
                    target_url=self.current_search_results.get('target', ''),
                    exploit_type=attempt.get('exploit_type', ''),
                    severity='Critical' if attempt.get('success') else 'High',
                    payload=attempt.get('payload', ''),
                    description=f"Successful exploit discovered via seek",
                    timestamp=time.time(),
                    instance_id=self.exploit_sharer.instance_id,
                    success=True
                )
                self.exploit_sharer.register_exploit(exploit)
                count += 1
        
        QMessageBox.information(self, "Shared", f"{count} exploits shared to network")
    
    def _clear_results(self):
        """Clear results"""
        self.results_table.setRowCount(0)
        self.details_output.clear()
        self.url_input.clear()
        self.current_search_results = {}
        self.status_label.setText("Ready")
        self.status_label.setStyleSheet("color: #4CAF50; font-weight: bold;")


def create_exploit_seek_tab(parent=None, exploit_sharer: P2PExploitSharer = None, hades_ai=None) -> ExploitSeekTab:
    """Factory function to create exploit seek tab with all available knowledge sources"""
    return ExploitSeekTab(parent, exploit_sharer, hades_ai)
