"""
Exploit Seek & Share Tab for HadesAI
Provides UI for P2P exploit searching and automatic exploitation
"""

from PyQt6.QtWidgets import (
    QWidget, QVBoxLayout, QHBoxLayout, QGroupBox, QLabel, QPushButton,
    QLineEdit, QTextEdit, QTableWidget, QTableWidgetItem, QProgressBar,
    QComboBox, QCheckBox, QSpinBox, QTabWidget, QMessageBox, QListWidget,
    QListWidgetItem, QSplitter, QStatusBar, QFormLayout
)
from PyQt6.QtCore import Qt, QThread, pyqtSignal, QTimer
from PyQt6.QtGui import QFont, QColor, QIcon
import json
import time
import logging
from typing import Optional, Callable, Dict, List
from p2p_exploit_sharing import (
    P2PExploitSharer, ExploitSeeker, ExploitFinding
)

logger = logging.getLogger("ExploitSeekTab")

try:
    from comprehensive_exploit_seeker import UnifiedExploitKnowledge
    HAS_UNIFIED_SEEKER = True
except ImportError:
    UnifiedExploitKnowledge = None
    HAS_UNIFIED_SEEKER = False


class SeekWorker(QThread):
    """Background worker for exploit seeking"""
    finished = pyqtSignal(dict)
    progress = pyqtSignal(str)
    error = pyqtSignal(str)
    
    def __init__(self, seeker: ExploitSeeker, target_url: str):
        super().__init__()
        self.seeker = seeker
        self.target_url = target_url
        self.setObjectName("SeekWorker")
    
    def run(self):
        try:
            self.progress.emit(f"Seeking exploits for {self.target_url}...")
            result = self.seeker.seek_and_attempt(
                self.target_url,
                callback=self._progress_callback
            )
            if result:
                self.finished.emit(result)
            else:
                self.error.emit("No result returned from seek")
        except Exception as e:
            self.error.emit(str(e))
    
    def _progress_callback(self, result: dict):
        if result:
            self.progress.emit(f"Exploit attempts: {len(result.get('attempts', []))}")


class UnifiedSeekWorker(QThread):
    """Background worker for unified exploit seeking from all sources"""
    finished = pyqtSignal(dict)
    progress = pyqtSignal(str)
    enumeration_progress = pyqtSignal(str)  # Per-source progress
    error = pyqtSignal(str)
    
    def __init__(self, unified_seeker, target_url: str):
        super().__init__()
        self.unified_seeker = unified_seeker
        self.target_url = target_url
        self.setObjectName("UnifiedSeekWorker")
    
    def run(self):
        try:
            self.progress.emit("Initiating comprehensive exploit enumeration...")
            self.enumeration_progress.emit("Searching 7 knowledge sources...")
            
            # Get exploits from all sources
            exploits = self.unified_seeker.seek_all_exploits(self.target_url)
            
            # Get source statistics
            source_stats = self.unified_seeker.get_source_stats(exploits)
            source_info = "\n".join([f"  {src}: {cnt}" for src, cnt in source_stats.items()])
            
            self.progress.emit(f"Enumeration complete: {len(exploits)} total exploits found")
            self.enumeration_progress.emit(f"Source breakdown:\n{source_info}")
            
            # Prepare result
            result = {
                'target': self.target_url,
                'status': 'completed',
                'attempts': exploits,
                'timestamp': time.time(),
                'total_exploits': len(exploits),
                'sources': source_stats,
                'enumeration_complete': True
            }
            
            self.finished.emit(result)
        except Exception as e:
            import traceback
            error_detail = f"Comprehensive seek error: {str(e)}\n{traceback.format_exc()}"
            logger.error(error_detail)
            self.error.emit(error_detail)


class ExploitSeekTab(QWidget):
    """Tab for exploit seeking and P2P sharing"""
    
    def __init__(self, parent=None, exploit_sharer: P2PExploitSharer = None, hades_ai=None):
        super().__init__(parent)
        self.exploit_sharer = exploit_sharer or P2PExploitSharer()
        self.hades_ai = hades_ai
        self.exploit_seeker = ExploitSeeker(self.exploit_sharer)
        
        # Use unified seeker if available
        self.unified_seeker = None
        if HAS_UNIFIED_SEEKER and hades_ai:
            self.unified_seeker = UnifiedExploitKnowledge(hades_ai, exploit_sharer)
        
        self.seek_worker = None
        self.current_search_results = {}
        self.init_ui()
        
        # Auto-refresh shared exploits
        self.refresh_timer = QTimer()
        self.refresh_timer.timeout.connect(self._refresh_shared_exploits)
        self.refresh_timer.start(5000)  # Every 5 seconds
    
    def closeEvent(self, event):
        """Cleanup threads on close"""
        self.refresh_timer.stop()
        if self.seek_worker and self.seek_worker.isRunning():
            self.seek_worker.quit()
            self.seek_worker.wait()
        super().closeEvent(event)
    
    def init_ui(self):
        layout = QVBoxLayout(self)
        
        # ===== SEEK SECTION =====
        seek_group = QGroupBox("ðŸ” Exploit Seeker")
        seek_layout = QVBoxLayout(seek_group)
        
        # URL input and buttons
        url_layout = QHBoxLayout()
        url_layout.addWidget(QLabel("Target URL:"))
        self.url_input = QLineEdit()
        self.url_input.setPlaceholderText("https://target.com or paste link here")
        url_layout.addWidget(self.url_input)
        
        # Main SEEK button (prominent)
        self.seek_button = QPushButton("âš¡ SEEK EXPLOITS")
        self.seek_button.setStyleSheet("""
            QPushButton {
                background-color: #ff4444;
                color: white;
                font-weight: bold;
                font-size: 12px;
                padding: 8px;
                border-radius: 4px;
            }
            QPushButton:hover {
                background-color: #ff2222;
            }
            QPushButton:pressed {
                background-color: #cc0000;
            }
        """)
        self.seek_button.clicked.connect(self._start_seek)
        self.seek_button.setCursor(Qt.CursorShape.PointingHandCursor)
        url_layout.addWidget(self.seek_button)
        
        # Auto-attempt checkbox
        self.auto_attempt_check = QCheckBox("Auto-Attempt")
        self.auto_attempt_check.setChecked(True)
        self.auto_attempt_check.setToolTip("Automatically attempt discovered exploits")
        url_layout.addWidget(self.auto_attempt_check)
        
        seek_layout.addLayout(url_layout)
        
        # Search options
        options_layout = QHBoxLayout()
        options_layout.addWidget(QLabel("Severity Filter:"))
        self.severity_filter = QComboBox()
        self.severity_filter.addItems(["All", "Critical", "High", "Medium", "Low"])
        options_layout.addWidget(self.severity_filter)
        
        options_layout.addWidget(QLabel("Max Attempts:"))
        self.max_attempts = QSpinBox()
        self.max_attempts.setValue(10)
        self.max_attempts.setRange(1, 100)
        options_layout.addWidget(self.max_attempts)
        
        options_layout.addWidget(QLabel("Timeout (sec):"))
        self.timeout_spin = QSpinBox()
        self.timeout_spin.setValue(30)
        self.timeout_spin.setRange(5, 300)
        options_layout.addWidget(self.timeout_spin)
        
        options_layout.addStretch()
        seek_layout.addLayout(options_layout)
        
        # Progress bar
        self.progress_bar = QProgressBar()
        self.progress_bar.setVisible(False)
        seek_layout.addWidget(self.progress_bar)
        
        # Status label
        self.status_label = QLabel("Ready")
        self.status_label.setStyleSheet("color: #4CAF50; font-weight: bold;")
        seek_layout.addWidget(self.status_label)
        
        layout.addWidget(seek_group)
        
        # ===== RESULTS TABS =====
        results_tabs = QTabWidget()
        
        # TAB 1: Search Results
        results_widget = QWidget()
        results_layout = QVBoxLayout(results_widget)
        
        self.results_table = QTableWidget()
        self.results_table.setColumnCount(6)
        self.results_table.setHorizontalHeaderLabels([
            "Exploit Type", "Severity", "Status", "Payload", "Description", "Source"
        ])
        self.results_table.setColumnWidth(0, 150)
        self.results_table.setColumnWidth(1, 80)
        self.results_table.setColumnWidth(2, 80)
        self.results_table.setColumnWidth(3, 200)
        self.results_table.setColumnWidth(4, 300)
        self.results_table.setColumnWidth(5, 100)
        results_layout.addWidget(QLabel("Discovered Exploits:"))
        results_layout.addWidget(self.results_table)
        
        results_tabs.addTab(results_widget, "Search Results")
        
        # TAB 2: Shared Network Exploits
        network_widget = QWidget()
        network_layout = QVBoxLayout(network_widget)
        
        self.network_list = QListWidget()
        network_layout.addWidget(QLabel("Exploits from Network Peers:"))
        network_layout.addWidget(self.network_list)
        
        # Network stats
        stats_layout = QHBoxLayout()
        self.stats_label = QLabel("Network Stats: 0 exploits, 0 critical")
        stats_layout.addWidget(self.stats_label)
        stats_layout.addStretch()
        
        refresh_btn = QPushButton("ðŸ”„ Refresh")
        refresh_btn.clicked.connect(self._refresh_shared_exploits)
        stats_layout.addWidget(refresh_btn)
        
        network_layout.addLayout(stats_layout)
        
        results_tabs.addTab(network_widget, "Network Shared Exploits")
        
        # TAB 3: Detailed Results
        details_widget = QWidget()
        details_layout = QVBoxLayout(details_widget)
        
        self.details_output = QTextEdit()
        self.details_output.setReadOnly(True)
        details_layout.addWidget(self.details_output)
        
        results_tabs.addTab(details_widget, "Detailed Analysis")
        
        layout.addWidget(results_tabs)
        
        # ===== ACTION BUTTONS =====
        action_layout = QHBoxLayout()
        
        export_btn = QPushButton("ðŸ“¤ Export Results")
        export_btn.clicked.connect(self._export_results)
        action_layout.addWidget(export_btn)
        
        share_btn = QPushButton("ðŸ”— Share to Network")
        share_btn.clicked.connect(self._share_to_network)
        action_layout.addWidget(share_btn)
        
        action_layout.addStretch()
        
        clear_btn = QPushButton("Clear")
        clear_btn.clicked.connect(self._clear_results)
        action_layout.addWidget(clear_btn)
        
        layout.addLayout(action_layout)
    
    def _start_seek(self):
        """Start seeking exploits for target"""
        target_url = self.url_input.text().strip()
        
        if not target_url:
            QMessageBox.warning(self, "Input Error", "Please enter a target URL")
            return
        
        # Ensure URL has protocol
        if not target_url.startswith(('http://', 'https://')):
            target_url = 'https://' + target_url
        
        self.url_input.setText(target_url)
        
        # Disable button during search
        self.seek_button.setEnabled(False)
        self.seek_button.setText("â³ SEEKING...")
        
        # Show progress
        self.progress_bar.setVisible(True)
        self.progress_bar.setValue(0)
        self.status_label.setText(f"Seeking exploits from ALL knowledge sources for {target_url}...")
        self.status_label.setStyleSheet("color: #ff9800; font-weight: bold;")
        
        # Start worker thread
        # Use unified seeker if available, otherwise fallback
        if self.unified_seeker:
            self.seek_worker = UnifiedSeekWorker(self.unified_seeker, target_url)
            # Connect enumeration progress for detailed feedback
            self.seek_worker.enumeration_progress.connect(self._on_enumeration_progress)
        else:
            self.seek_worker = SeekWorker(self.exploit_seeker, target_url)
        
        self.seek_worker.finished.connect(self._on_seek_finished)
        self.seek_worker.progress.connect(self._on_seek_progress)
        self.seek_worker.error.connect(self._on_seek_error)
        self.seek_worker.start()
    
    def _on_seek_finished(self, result: dict):
        """Handle seek completion"""
        try:
            self.current_search_results = result
            
            # Update UI
            self.seek_button.setEnabled(True)
            self.seek_button.setText("âš¡ SEEK EXPLOITS")
            self.progress_bar.setVisible(False)
            
            attempts = result.get('attempts', [])
            successful = sum(1 for a in attempts if a.get('success'))
            
            if result['status'] == 'exploited':
                self.status_label.setText(f"âœ… SUCCESS! Exploited with {successful} successful attempts")
                self.status_label.setStyleSheet("color: #4CAF50; font-weight: bold;")
            elif attempts:
                self.status_label.setText(f"âš ï¸  Found {len(attempts)} exploits, {successful} successful")
                self.status_label.setStyleSheet("color: #ff9800; font-weight: bold;")
            else:
                self.status_label.setText("âŒ No exploits found for target")
                self.status_label.setStyleSheet("color: #f44336; font-weight: bold;")
            
            # Display results
            self._display_results(result)
        except Exception as e:
            self.status_label.setText(f"Error: {str(e)}")
            self.status_label.setStyleSheet("color: #f44336; font-weight: bold;")
    
    def _on_seek_progress(self, message: str):
        """Handle progress update"""
        self.status_label.setText(message)
    
    def _on_enumeration_progress(self, message: str):
        """Handle enumeration source progress"""
        # Append to details output for visibility
        current = self.details_output.toPlainText()
        if current and not current.endswith('\n\n'):
            current += '\n'
        self.details_output.setText(current + message)
        # Scroll to bottom
        self.details_output.verticalScrollBar().setValue(
            self.details_output.verticalScrollBar().maximum()
        )
    
    def _on_seek_error(self, error: str):
        """Handle seek error"""
        self.seek_button.setEnabled(True)
        self.seek_button.setText("âš¡ SEEK EXPLOITS")
        self.progress_bar.setVisible(False)
        self.status_label.setText(f"âŒ Error: {error}")
        self.status_label.setStyleSheet("color: #f44336; font-weight: bold;")
        QMessageBox.critical(self, "Seek Error", error)
    
    def _display_results(self, result: dict):
        """Display search results in table (thread-safe)"""
        try:
            self.results_table.setRowCount(0)
            
            attempts = result.get('attempts', [])
            for attempt in attempts:
                row = self.results_table.rowCount()
                self.results_table.insertRow(row)
                
                exploit_type = attempt.get('exploit_type', 'Unknown')
                success = "âœ… Success" if attempt.get('success') else "âŒ Failed"
                severity = "Critical" if attempt.get('success') else "High"
                
                items = [
                    exploit_type,
                    severity,
                    success,
                    attempt.get('payload', '')[:50],
                    f"Attempt {row + 1}",
                    "Local"
                ]
                
                for col, item in enumerate(items):
                    cell = QTableWidgetItem(str(item))
                    if success == "âœ… Success":
                        cell.setBackground(QColor(100, 255, 100))
                    self.results_table.setItem(row, col, cell)
            
            # Detailed output
            details = f"""
â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
â•‘          EXPLOIT SEEK RESULTS             â•‘
â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

Target: {result.get('target', 'Unknown')}
Status: {result.get('status', 'Unknown')}
Timestamp: {time.ctime(result.get('timestamp', time.time()))}

â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

ATTEMPTS SUMMARY:
Total Attempts: {len(attempts)}
Successful: {sum(1 for a in attempts if a.get('success'))}
Failed: {sum(1 for a in attempts if not a.get('success'))}

â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

DETAILED RESULTS:
"""
            for i, attempt in enumerate(attempts, 1):
                details += f"""
Attempt {i}:
  Type: {attempt.get('exploit_type')}
  Status: {'âœ… SUCCESS' if attempt.get('success') else 'âŒ FAILED'}
  Payload: {attempt.get('payload', 'N/A')}
  Error: {attempt.get('error', 'None')}
"""
            
            self.details_output.setText(details)
        except Exception as e:
            self.status_label.setText(f"Error displaying results: {str(e)}")
            self.status_label.setStyleSheet("color: #f44336; font-weight: bold;")
    
    def _refresh_shared_exploits(self):
        """Refresh exploits from network"""
        if not self.exploit_sharer:
            return
        
        stats = self.exploit_sharer.get_network_statistics()
        
        # Update stats label
        self.stats_label.setText(
            f"Network Stats: {stats['total_exploits']} exploits, "
            f"{stats['critical_count']} critical, "
            f"{stats['high_count']} high"
        )
        
        # Update network list
        self.network_list.clear()
        
        all_exploits = (
            self.exploit_sharer.registry.get_all_exploits() +
            list(self.exploit_sharer.received_exploits.values())
        )
        
        for exploit in sorted(all_exploits, 
                             key=lambda e: {'Critical': 0, 'High': 1, 'Medium': 2, 'Low': 3}.get(e.severity, 4)):
            item_text = f"[{exploit.severity}] {exploit.exploit_type} - {exploit.target_url}"
            item = QListWidgetItem(item_text)
            
            # Color by severity
            if exploit.severity == 'Critical':
                item.setBackground(QColor(255, 100, 100))
            elif exploit.severity == 'High':
                item.setBackground(QColor(255, 165, 0))
            
            self.network_list.addItem(item)
    
    def _export_results(self):
        """Export current results"""
        if not self.current_search_results:
            QMessageBox.warning(self, "No Results", "No search results to export")
            return
        
        filename = self.exploit_sharer.export_exploits()
        QMessageBox.information(self, "Exported", f"Results exported to {filename}")
    
    def _share_to_network(self):
        """Share current results to P2P network"""
        if not self.exploit_sharer.network_node:
            QMessageBox.warning(self, "Network Unavailable", 
                              "P2P network not configured. Enable Network Sharing first.")
            return
        
        attempts = self.current_search_results.get('attempts', [])
        if not attempts:
            QMessageBox.warning(self, "No Results", "No exploits to share")
            return
        
        count = 0
        for attempt in attempts:
            if attempt.get('success'):
                exploit = ExploitFinding(
                    exploit_id=f"{attempt['exploit_id']}_{int(time.time())}",
                    target_url=self.current_search_results.get('target', ''),
                    exploit_type=attempt.get('exploit_type', ''),
                    severity='Critical' if attempt.get('success') else 'High',
                    payload=attempt.get('payload', ''),
                    description=f"Successful exploit discovered via seek",
                    timestamp=time.time(),
                    instance_id=self.exploit_sharer.instance_id,
                    success=True
                )
                self.exploit_sharer.register_exploit(exploit)
                count += 1
        
        QMessageBox.information(self, "Shared", f"{count} exploits shared to network")
    
    def _clear_results(self):
        """Clear results"""
        self.results_table.setRowCount(0)
        self.details_output.clear()
        self.url_input.clear()
        self.current_search_results = {}
        self.status_label.setText("Ready")
        self.status_label.setStyleSheet("color: #4CAF50; font-weight: bold;")


def create_exploit_seek_tab(parent=None, exploit_sharer: P2PExploitSharer = None, hades_ai=None) -> ExploitSeekTab:
    """Factory function to create exploit seek tab with all available knowledge sources"""
    return ExploitSeekTab(parent, exploit_sharer, hades_ai)
