"""
AI-Powered Vulnerability Testing for Authorized Websites
Integrates with HadesAI to provide one-click comprehensive security testing
"""

import logging
import json
import time
import threading
from typing import Dict, List, Optional, Tuple
from dataclasses import dataclass
from datetime import datetime
import requests
from urllib.parse import urlparse, urljoin

logger = logging.getLogger("AIVulnerabilityTester")


@dataclass
class VulnerabilityTest:
    """Represents a single vulnerability test"""
    test_id: str
    test_name: str
    test_type: str  # injection, auth, config, etc.
    severity: str
    payload: str
    expected_indicators: List[str]
    requires_auth: bool = False
    timeout: int = 10


@dataclass
class TestResult:
    """Result of a vulnerability test"""
    test_id: str
    test_name: str
    vulnerable: bool
    confidence: float
    evidence: str
    response_code: int
    response_time: float
    timestamp: float
    payload_used: str


class AIVulnerabilityTester:
    """
    AI-powered vulnerability tester for authorized targets
    Uses HadesAI's knowledge base and attack vectors to intelligently test websites
    """
    
    # Define smart test categories
    VULNERABILITY_TESTS = {
        'injection': [
            VulnerabilityTest(
                'sql_001', 'SQL Injection - Basic',
                'injection', 'Critical',
                "' OR '1'='1'--",
                ["error", "syntax", "sql", "database"],
                False
            ),
            VulnerabilityTest(
                'sql_002', 'SQL Injection - Union',
                'injection', 'Critical',
                "' UNION SELECT NULL,NULL--",
                ["error", "union", "select"],
                False
            ),
            VulnerabilityTest(
                'xss_001', 'XSS - Basic Script',
                'injection', 'High',
                '<img src=x onerror="alert(1)">',
                ["alert", "onerror", "script"],
                False
            ),
            VulnerabilityTest(
                'xss_002', 'XSS - Event Handler',
                'injection', 'High',
                '"><svg onload="alert(1)">',
                ["svg", "onload", "alert"],
                False
            ),
        ],
        'authentication': [
            VulnerabilityTest(
                'auth_001', 'Default Credentials',
                'auth', 'High',
                'admin:admin',
                ["success", "welcome", "dashboard"],
                True
            ),
            VulnerabilityTest(
                'auth_002', 'Weak Password',
                'auth', 'Medium',
                'admin:password',
                ["success", "welcome", "dashboard"],
                True
            ),
            VulnerabilityTest(
                'auth_003', 'Bypass - No Auth',
                'auth', 'High',
                '',  # No credentials
                ["admin", "protected"],
                False
            ),
        ],
        'configuration': [
            VulnerabilityTest(
                'config_001', 'Debug Mode Enabled',
                'config', 'High',
                '?debug=1',
                ["debug", "trace", "stack"],
                False
            ),
            VulnerabilityTest(
                'config_002', 'Admin Panel Exposed',
                'config', 'Critical',
                '/admin',
                ["admin", "login", "panel"],
                False
            ),
            VulnerabilityTest(
                'config_003', 'Backup Files',
                'config', 'High',
                '/.backup',
                ["backup", "tar", "zip"],
                False
            ),
        ],
        'headers': [
            VulnerabilityTest(
                'header_001', 'Missing Security Headers',
                'headers', 'Medium',
                '',
                ["x-frame-options", "csp"],
                False
            ),
            VulnerabilityTest(
                'header_002', 'CORS Misconfiguration',
                'headers', 'High',
                '',
                ["access-control-allow-origin"],
                False
            ),
        ],
        'information_disclosure': [
            VulnerabilityTest(
                'info_001', 'Directory Listing',
                'info', 'Medium',
                '/',
                ["index of", "directory", "[dir]"],
                False
            ),
            VulnerabilityTest(
                'info_002', 'Version Disclosure',
                'info', 'Low',
                '',
                ["version", "powered by"],
                False
            ),
        ]
    }
    
    def __init__(self, hades_ai=None):
        self.hades_ai = hades_ai
        self.session = self._create_session()
        self.test_results: List[TestResult] = []
        self.target_url = None
        self.authorization_token = None
        self.auth_headers = {}
        
    def _create_session(self) -> requests.Session:
        """Create requests session with retry logic"""
        session = requests.Session()
        session.headers.update({
            'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36'
        })
        
        # Suppress SSL warnings
        import urllib3
        urllib3.disable_warnings(urllib3.exceptions.InsecureRequestWarning)
        
        return session
    
    def set_authorization(self, token: Optional[str] = None, headers: Optional[Dict] = None):
        """Set authorization for protected endpoints"""
        if token:
            self.authorization_token = token
            self.auth_headers = {
                'Authorization': f'Bearer {token}'
            }
        elif headers:
            self.auth_headers = headers
    
    def test_website(self, target_url: str, test_categories: Optional[List[str]] = None,
                    callback: Optional[callable] = None) -> Dict:
        """
        Execute comprehensive vulnerability testing on authorized website
        
        Args:
            target_url: URL to test
            test_categories: Specific categories to test (default: all)
            callback: Function to call with progress updates
            
        Returns:
            Dictionary with all test results and summary
        """
        self.target_url = target_url
        self.test_results = []
        
        # Validate URL format
        if not self._validate_url(target_url):
            return {'error': 'Invalid URL format', 'status': 'failed'}
        
        # Get test categories to run
        categories = test_categories or list(self.VULNERABILITY_TESTS.keys())
        
        if callback:
            callback(f"Starting comprehensive vulnerability test on {target_url}")
        
        # Run tests by category
        for category in categories:
            if category not in self.VULNERABILITY_TESTS:
                logger.warning(f"Unknown test category: {category}")
                continue
            
            tests = self.VULNERABILITY_TESTS[category]
            
            if callback:
                callback(f"Testing {category}: {len(tests)} tests")
            
            for test in tests:
                if callback:
                    callback(f"  â†’ Running {test.test_name}...")
                
                result = self._run_single_test(target_url, test)
                if result:
                    self.test_results.append(result)
                
                time.sleep(0.5)  # Rate limiting
        
        # Compile results
        summary = self._compile_summary()
        
        if callback:
            callback(f"Testing complete: {summary['total_tests']} tests, "
                    f"{summary['vulnerabilities_found']} vulnerabilities found")
        
        return summary
    
    def _validate_url(self, url: str) -> bool:
        """Validate URL format"""
        try:
            result = urlparse(url)
            return all([result.scheme in ['http', 'https'], result.netloc])
        except:
            return False
    
    def _run_single_test(self, target_url: str, test: VulnerabilityTest) -> Optional[TestResult]:
        """Execute a single vulnerability test"""
        try:
            start_time = time.time()
            
            # Prepare test URL and payload
            if test.test_type == 'injection':
                test_url = self._prepare_injection_test(target_url, test)
            elif test.test_type == 'auth':
                test_url = self._prepare_auth_test(target_url, test)
            elif test.test_type == 'config':
                test_url = urljoin(target_url, test.payload)
            else:
                test_url = target_url
            
            # Make request with timeout
            headers = self.auth_headers.copy() if self.auth_headers else {}
            
            response = self.session.get(
                test_url,
                headers=headers,
                timeout=test.timeout,
                verify=False,
                allow_redirects=True
            )
            
            elapsed_time = time.time() - start_time
            
            # Analyze response for vulnerability indicators
            vulnerable, confidence, evidence = self._analyze_response(
                response, test
            )
            
            result = TestResult(
                test_id=test.test_id,
                test_name=test.test_name,
                vulnerable=vulnerable,
                confidence=confidence,
                evidence=evidence,
                response_code=response.status_code,
                response_time=elapsed_time,
                timestamp=time.time(),
                payload_used=test.payload
            )
            
            logger.info(f"Test {test.test_id}: {'VULNERABLE' if vulnerable else 'safe'} "
                       f"(confidence: {confidence:.0%})")
            
            return result
            
        except requests.Timeout:
            logger.warning(f"Test {test.test_id} timed out")
            return None
        except Exception as e:
            logger.error(f"Test {test.test_id} failed: {e}")
            return None
    
    def _prepare_injection_test(self, base_url: str, test: VulnerabilityTest) -> str:
        """Prepare URL for injection testing"""
        # Test common parameter names
        param_names = ['id', 'search', 'q', 'name', 'username', 'email', 'page']
        
        # Try first parameter found in URL
        if '?' in base_url:
            return f"{base_url}&{param_names[0]}={test.payload}"
        else:
            return f"{base_url}?{param_names[0]}={test.payload}"
    
    def _prepare_auth_test(self, base_url: str, test: VulnerabilityTest) -> str:
        """Prepare request for auth testing"""
        return base_url
    
    def _analyze_response(self, response: requests.Response, 
                         test: VulnerabilityTest) -> Tuple[bool, float, str]:
        """Analyze response for vulnerability indicators"""
        content_lower = response.text.lower()
        
        # Check for expected indicators
        matched_indicators = []
        for indicator in test.expected_indicators:
            if indicator.lower() in content_lower:
                matched_indicators.append(indicator)
        
        # Heuristic scoring
        if test.test_type == 'injection':
            # For injection tests, look for error messages
            error_keywords = ['error', 'exception', 'syntax', 'warning', 'trace', 'stack']
            error_matches = sum(1 for kw in error_keywords if kw in content_lower)
            
            # Interesting status codes
            interesting_status = response.status_code in [200, 302, 403, 500]
            
            vulnerability = error_matches >= 2 or interesting_status
            confidence = min(1.0, (error_matches * 0.3 + len(matched_indicators) * 0.2))
            
        elif test.test_type == 'auth':
            # For auth, look for success indicators
            success_keywords = ['dashboard', 'welcome', 'logout', 'profile', 'success']
            success_matches = sum(1 for kw in success_keywords if kw in content_lower)
            
            vulnerability = success_matches >= 1 and response.status_code == 200
            confidence = min(1.0, success_matches * 0.4)
            
        elif test.test_type == 'config':
            vulnerability = response.status_code == 200 and len(matched_indicators) > 0
            confidence = min(1.0, len(matched_indicators) * 0.3)
            
        else:
            vulnerability = len(matched_indicators) > 0
            confidence = min(1.0, len(matched_indicators) * 0.2)
        
        evidence = f"Indicators: {', '.join(matched_indicators) if matched_indicators else 'None'}"
        
        return vulnerability, confidence, evidence
    
    def _compile_summary(self) -> Dict:
        """Compile test results into summary"""
        vulnerabilities = [r for r in self.test_results if r.vulnerable]
        
        severity_breakdown = {
            'Critical': len([v for v in vulnerabilities if 'critical' in 
                           next((t for t in [test for tests in self.VULNERABILITY_TESTS.values() 
                                            for test in tests] if t.test_id == v.test_id), 
                                VulnerabilityTest('', '', '', 'Low', '', [], False)).severity.lower()]),
            'High': 0,
            'Medium': 0,
            'Low': 0
        }
        
        return {
            'target': self.target_url,
            'timestamp': time.time(),
            'total_tests': len(self.test_results),
            'vulnerabilities_found': len(vulnerabilities),
            'success_rate': f"{(len(vulnerabilities) / max(1, len(self.test_results))) * 100:.1f}%",
            'avg_response_time': f"{sum(r.response_time for r in self.test_results) / max(1, len(self.test_results)):.2f}s",
            'results': [
                {
                    'test_id': r.test_id,
                    'test_name': r.test_name,
                    'vulnerable': r.vulnerable,
                    'confidence': f"{r.confidence:.0%}",
                    'response_code': r.response_code,
                    'response_time': f"{r.response_time:.2f}s",
                    'evidence': r.evidence,
                    'payload': r.payload_used
                }
                for r in sorted(self.test_results, key=lambda x: x.vulnerable, reverse=True)
            ],
            'severity_breakdown': severity_breakdown,
            'status': 'completed'
        }
    
    def export_results(self, filename: str = None) -> str:
        """Export test results to JSON"""
        if not filename:
            timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
            filename = f"vuln_test_{timestamp}.json"
        
        summary = self._compile_summary()
        
        with open(filename, 'w') as f:
            json.dump(summary, f, indent=2)
        
        logger.info(f"Results exported to {filename}")
        return filename
    
    def get_remediation_recommendations(self) -> Dict:
        """Generate AI-powered remediation recommendations"""
        vulnerabilities = [r for r in self.test_results if r.vulnerable]
        
        recommendations = {
            'critical': [],
            'high': [],
            'medium': [],
            'low': []
        }
        
        # Add remediation for each vulnerability
        for vuln in vulnerabilities:
            if 'sql' in vuln.test_id.lower():
                recommendations['critical'].append({
                    'vulnerability': vuln.test_name,
                    'fix': 'Use parameterized queries and prepared statements',
                    'priority': 'CRITICAL'
                })
            elif 'xss' in vuln.test_id.lower():
                recommendations['high'].append({
                    'vulnerability': vuln.test_name,
                    'fix': 'Implement input validation, output encoding, and Content Security Policy',
                    'priority': 'HIGH'
                })
            elif 'auth' in vuln.test_id.lower():
                recommendations['high'].append({
                    'vulnerability': vuln.test_name,
                    'fix': 'Enforce strong passwords, implement MFA, disable default credentials',
                    'priority': 'HIGH'
                })
            elif 'config' in vuln.test_id.lower():
                recommendations['high'].append({
                    'vulnerability': vuln.test_name,
                    'fix': 'Disable debug modes, remove admin panels from public access',
                    'priority': 'HIGH'
                })
        
        return recommendations
