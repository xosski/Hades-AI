"""
Exploit Tome - Centralized Repository of Working Exploits
Stores, categorizes, and displays all active/working exploits with full metadata
"""

import json
import sqlite3
from datetime import datetime
from pathlib import Path
from typing import Dict, List, Optional, Tuple
from dataclasses import dataclass, asdict
import logging

logger = logging.getLogger(__name__)


@dataclass
class ExploitEntry:
    """Represents a single exploit in the tome"""
    id: str
    name: str
    category: str
    target: str
    payload: str
    success_count: int = 0
    fail_count: int = 0
    last_used: Optional[str] = None
    created_at: Optional[str] = None
    status: str = "active"  # active, archived, testing
    notes: str = ""
    tags: List[str] = None
    cve_ids: List[str] = None
    reference_links: List[str] = None
    
    def __post_init__(self):
        if self.tags is None:
            self.tags = []
        if self.cve_ids is None:
            self.cve_ids = []
        if self.reference_links is None:
            self.reference_links = []
    
    def get_success_rate(self) -> float:
        """Calculate success rate percentage"""
        total = self.success_count + self.fail_count
        return (self.success_count / total * 100) if total > 0 else 0
    
    def to_dict(self) -> Dict:
        """Convert to dictionary with serialized lists"""
        d = asdict(self)
        d['tags'] = json.dumps(self.tags)
        d['cve_ids'] = json.dumps(self.cve_ids)
        d['reference_links'] = json.dumps(self.reference_links)
        return d


class ExploitTome:
    """Database manager for the exploit tome"""
    
    def __init__(self, db_path: str = "exploit_tome.db"):
        self.db_path = db_path
        self.conn = None
        self.lock = None
        self._init_db()
    
    def _init_db(self):
        """Initialize the database with required tables"""
        self.conn = sqlite3.connect(self.db_path, check_same_thread=False)
        cursor = self.conn.cursor()
        
        # Main exploits table
        cursor.execute('''CREATE TABLE IF NOT EXISTS exploits (
            id TEXT PRIMARY KEY,
            name TEXT NOT NULL,
            category TEXT NOT NULL,
            target TEXT NOT NULL,
            payload TEXT NOT NULL,
            success_count INTEGER DEFAULT 0,
            fail_count INTEGER DEFAULT 0,
            last_used TEXT,
            created_at TEXT NOT NULL,
            status TEXT DEFAULT 'active',
            notes TEXT DEFAULT '',
            tags TEXT DEFAULT '[]',
            cve_ids TEXT DEFAULT '[]',
            reference_links TEXT DEFAULT '[]'
        )''')
        
        # Execution history
        cursor.execute('''CREATE TABLE IF NOT EXISTS execution_history (
            id INTEGER PRIMARY KEY AUTOINCREMENT,
            exploit_id TEXT NOT NULL,
            target_url TEXT NOT NULL,
            timestamp TEXT NOT NULL,
            result TEXT NOT NULL,
            response TEXT DEFAULT '',
            error TEXT DEFAULT '',
            FOREIGN KEY (exploit_id) REFERENCES exploits(id)
        )''')
        
        # Exploit categories/collections
        cursor.execute('''CREATE TABLE IF NOT EXISTS exploit_collections (
            id INTEGER PRIMARY KEY AUTOINCREMENT,
            name TEXT NOT NULL UNIQUE,
            description TEXT DEFAULT '',
            created_at TEXT NOT NULL
        )''')
        
        # Many-to-many: exploits in collections
        cursor.execute('''CREATE TABLE IF NOT EXISTS collection_members (
            collection_id INTEGER NOT NULL,
            exploit_id TEXT NOT NULL,
            FOREIGN KEY (collection_id) REFERENCES exploit_collections(id),
            FOREIGN KEY (exploit_id) REFERENCES exploits(id),
            PRIMARY KEY (collection_id, exploit_id)
        )''')
        
        self.conn.commit()
    
    # ========== EXPLOIT MANAGEMENT ==========
    
    def add_exploit(self, exploit: ExploitEntry) -> bool:
        """Add a new exploit to the tome"""
        try:
            cursor = self.conn.cursor()
            data = exploit.to_dict()
            columns = ', '.join(data.keys())
            placeholders = ', '.join(['?' for _ in data])
            cursor.execute(f'INSERT INTO exploits ({columns}) VALUES ({placeholders})', 
                         list(data.values()))
            self.conn.commit()
            logger.info(f"Added exploit: {exploit.name}")
            return True
        except Exception as e:
            logger.error(f"Failed to add exploit: {e}")
            return False
    
    def update_exploit(self, exploit_id: str, **kwargs) -> bool:
        """Update exploit fields"""
        try:
            cursor = self.conn.cursor()
            updates = []
            values = []
            
            for key, value in kwargs.items():
                if isinstance(value, (list, dict)):
                    value = json.dumps(value)
                updates.append(f"{key} = ?")
                values.append(value)
            
            values.append(exploit_id)
            query = f"UPDATE exploits SET {', '.join(updates)} WHERE id = ?"
            cursor.execute(query, values)
            self.conn.commit()
            return True
        except Exception as e:
            logger.error(f"Failed to update exploit: {e}")
            return False
    
    def get_exploit(self, exploit_id: str) -> Optional[ExploitEntry]:
        """Retrieve a single exploit"""
        try:
            cursor = self.conn.cursor()
            cursor.execute('SELECT * FROM exploits WHERE id = ?', (exploit_id,))
            row = cursor.fetchone()
            if not row:
                return None
            
            cols = [desc[0] for desc in cursor.description]
            data = dict(zip(cols, row))
            
            # Deserialize JSON fields
            data['tags'] = json.loads(data.get('tags', '[]'))
            data['cve_ids'] = json.loads(data.get('cve_ids', '[]'))
            data['references'] = json.loads(data.get('references', '[]'))
            
            return ExploitEntry(**data)
        except Exception as e:
            logger.error(f"Failed to get exploit: {e}")
            return None
    
    def get_all_exploits(self, status: str = None, category: str = None, 
                        limit: int = None) -> List[ExploitEntry]:
        """Get all exploits with optional filters"""
        try:
            cursor = self.conn.cursor()
            query = 'SELECT * FROM exploits WHERE 1=1'
            params = []
            
            if status:
                query += ' AND status = ?'
                params.append(status)
            
            if category:
                query += ' AND category = ?'
                params.append(category)
            
            query += ' ORDER BY created_at DESC'
            
            if limit:
                query += ' LIMIT ?'
                params.append(limit)
            
            cursor.execute(query, params)
            rows = cursor.fetchall()
            
            exploits = []
            cols = [desc[0] for desc in cursor.description]
            
            for row in rows:
                 data = dict(zip(cols, row))
                 data['tags'] = json.loads(data.get('tags', '[]'))
                 data['cve_ids'] = json.loads(data.get('cve_ids', '[]'))
                 data['reference_links'] = json.loads(data.get('reference_links', '[]'))
                 exploits.append(ExploitEntry(**data))
            
            return exploits
        except Exception as e:
            logger.error(f"Failed to get exploits: {e}")
            return []
    
    def search_exploits(self, query: str, search_fields: List[str] = None) -> List[ExploitEntry]:
        """Search exploits by name, category, tags, or notes"""
        try:
            if search_fields is None:
                search_fields = ['name', 'category', 'notes', 'tags', 'cve_ids']
            
            cursor = self.conn.cursor()
            where_clauses = []
            
            for field in search_fields:
                if field in ['tags', 'cve_ids']:
                    where_clauses.append(f"{field} LIKE ?")
                else:
                    where_clauses.append(f"{field} LIKE ?")
            
            query_pattern = f"%{query}%"
            sql = f"SELECT * FROM exploits WHERE {' OR '.join(where_clauses)} ORDER BY created_at DESC"
            params = [query_pattern] * len(where_clauses)
            
            cursor.execute(sql, params)
            rows = cursor.fetchall()
            
            exploits = []
            cols = [desc[0] for desc in cursor.description]
            
            for row in rows:
                data = dict(zip(cols, row))
                data['tags'] = json.loads(data.get('tags', '[]'))
                data['cve_ids'] = json.loads(data.get('cve_ids', '[]'))
                data['reference_links'] = json.loads(data.get('reference_links', '[]'))
                exploits.append(ExploitEntry(**data))
            
            return exploits
        except Exception as e:
            logger.error(f"Failed to search exploits: {e}")
            return []
    
    def delete_exploit(self, exploit_id: str) -> bool:
        """Delete an exploit and its history"""
        try:
            cursor = self.conn.cursor()
            cursor.execute('DELETE FROM execution_history WHERE exploit_id = ?', (exploit_id,))
            cursor.execute('DELETE FROM exploits WHERE id = ?', (exploit_id,))
            self.conn.commit()
            logger.info(f"Deleted exploit: {exploit_id}")
            return True
        except Exception as e:
            logger.error(f"Failed to delete exploit: {e}")
            return False
    
    def get_categories(self) -> List[str]:
        """Get all unique exploit categories"""
        try:
            cursor = self.conn.cursor()
            cursor.execute('SELECT DISTINCT category FROM exploits ORDER BY category')
            return [row[0] for row in cursor.fetchall()]
        except Exception as e:
            logger.error(f"Failed to get categories: {e}")
            return []
    
    def get_statistics(self) -> Dict:
        """Get overall tome statistics"""
        try:
            cursor = self.conn.cursor()
            
            # Total exploits
            cursor.execute('SELECT COUNT(*) FROM exploits')
            total = cursor.fetchone()[0]
            
            # By status
            cursor.execute('SELECT status, COUNT(*) FROM exploits GROUP BY status')
            by_status = dict(cursor.fetchall())
            
            # By category
            cursor.execute('SELECT category, COUNT(*) FROM exploits GROUP BY category')
            by_category = dict(cursor.fetchall())
            
            # Success rate
            cursor.execute('SELECT SUM(success_count), SUM(fail_count) FROM exploits')
            success, fails = cursor.fetchone()
            success_rate = (success / (success + fails) * 100) if (success + fails) > 0 else 0
            
            # Most successful
            cursor.execute('''SELECT id, name, success_count FROM exploits 
                            ORDER BY success_count DESC LIMIT 5''')
            most_successful = [{'id': r[0], 'name': r[1], 'count': r[2]} for r in cursor.fetchall()]
            
            return {
                'total_exploits': total,
                'by_status': by_status,
                'by_category': by_category,
                'overall_success_rate': success_rate,
                'most_successful': most_successful
            }
        except Exception as e:
            logger.error(f"Failed to get statistics: {e}")
            return {}
    
    # ========== EXECUTION TRACKING ==========
    
    def log_execution(self, exploit_id: str, target_url: str, result: str, 
                     response: str = "", error: str = "") -> bool:
        """Log an exploit execution attempt"""
        try:
            cursor = self.conn.cursor()
            cursor.execute('''INSERT INTO execution_history 
                            (exploit_id, target_url, timestamp, result, response, error)
                            VALUES (?, ?, ?, ?, ?, ?)''',
                         (exploit_id, target_url, datetime.now().isoformat(), 
                          result, response, error))
            
            # Update success/fail count
            if result == "success":
                self.update_exploit(exploit_id, 
                                  success_count=self.get_exploit(exploit_id).success_count + 1,
                                  last_used=datetime.now().isoformat())
            else:
                self.update_exploit(exploit_id,
                                  fail_count=self.get_exploit(exploit_id).fail_count + 1)
            
            self.conn.commit()
            return True
        except Exception as e:
            logger.error(f"Failed to log execution: {e}")
            return False
    
    def get_execution_history(self, exploit_id: str, limit: int = 20) -> List[Dict]:
        """Get execution history for an exploit"""
        try:
            cursor = self.conn.cursor()
            cursor.execute('''SELECT * FROM execution_history 
                            WHERE exploit_id = ? 
                            ORDER BY timestamp DESC 
                            LIMIT ?''', (exploit_id, limit))
            
            cols = [desc[0] for desc in cursor.description]
            return [dict(zip(cols, row)) for row in cursor.fetchall()]
        except Exception as e:
            logger.error(f"Failed to get execution history: {e}")
            return []
    
    # ========== COLLECTIONS ==========
    
    def create_collection(self, name: str, description: str = "") -> bool:
        """Create a new exploit collection"""
        try:
            cursor = self.conn.cursor()
            cursor.execute('''INSERT INTO exploit_collections (name, description, created_at)
                            VALUES (?, ?, ?)''',
                         (name, description, datetime.now().isoformat()))
            self.conn.commit()
            return True
        except Exception as e:
            logger.error(f"Failed to create collection: {e}")
            return False
    
    def add_to_collection(self, collection_name: str, exploit_id: str) -> bool:
        """Add exploit to collection"""
        try:
            cursor = self.conn.cursor()
            cursor.execute('SELECT id FROM exploit_collections WHERE name = ?', 
                         (collection_name,))
            coll_id = cursor.fetchone()
            if not coll_id:
                return False
            
            cursor.execute('''INSERT INTO collection_members (collection_id, exploit_id)
                            VALUES (?, ?)''', (coll_id[0], exploit_id))
            self.conn.commit()
            return True
        except Exception as e:
            logger.error(f"Failed to add to collection: {e}")
            return False
    
    def get_collection_exploits(self, collection_name: str) -> List[ExploitEntry]:
        """Get all exploits in a collection"""
        try:
            cursor = self.conn.cursor()
            cursor.execute('''SELECT e.* FROM exploits e
                            JOIN collection_members cm ON e.id = cm.exploit_id
                            JOIN exploit_collections ec ON cm.collection_id = ec.id
                            WHERE ec.name = ?''', (collection_name,))
            
            rows = cursor.fetchall()
            exploits = []
            cols = [desc[0] for desc in cursor.description]
            
            for row in rows:
                data = dict(zip(cols, row))
                data['tags'] = json.loads(data.get('tags', '[]'))
                data['cve_ids'] = json.loads(data.get('cve_ids', '[]'))
                data['reference_links'] = json.loads(data.get('reference_links', '[]'))
                exploits.append(ExploitEntry(**data))
            
            return exploits
        except Exception as e:
            logger.error(f"Failed to get collection exploits: {e}")
            return []
    
    def get_collections(self) -> List[Dict]:
        """Get all collections"""
        try:
            cursor = self.conn.cursor()
            cursor.execute('SELECT id, name, description, created_at FROM exploit_collections')
            cols = [desc[0] for desc in cursor.description]
            return [dict(zip(cols, row)) for row in cursor.fetchall()]
        except Exception as e:
            logger.error(f"Failed to get collections: {e}")
            return []
    
    def export_to_json(self, filename: str, status: str = None) -> bool:
        """Export exploits to JSON file"""
        try:
            exploits = self.get_all_exploits(status=status)
            data = {
                'exported_at': datetime.now().isoformat(),
                'stats': self.get_statistics(),
                'exploits': [asdict(e) for e in exploits]
            }
            
            with open(filename, 'w') as f:
                json.dump(data, f, indent=2)
            
            logger.info(f"Exported to {filename}")
            return True
        except Exception as e:
            logger.error(f"Failed to export: {e}")
            return False
    
    def import_from_json(self, filename: str) -> int:
        """Import exploits from JSON file"""
        try:
            with open(filename, 'r') as f:
                data = json.load(f)
            
            count = 0
            for exploit_data in data.get('exploits', []):
                exploit = ExploitEntry(**exploit_data)
                if self.add_exploit(exploit):
                    count += 1
            
            logger.info(f"Imported {count} exploits from {filename}")
            return count
        except Exception as e:
            logger.error(f"Failed to import: {e}")
            return 0
