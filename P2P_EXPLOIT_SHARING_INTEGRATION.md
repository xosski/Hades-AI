# P2P Exploit Sharing & Seeking Integration Guide

## Overview

The P2P Exploit Sharing system enables automatic sharing of discovered exploits across the peer-to-peer network, with intelligent seeking and auto-exploitation capabilities.

## Features

### 1. **Exploit Registry & Sharing**
- Automatically registers discovered exploits locally
- Broadcasts exploits to all trusted peers
- Receives exploits from network peers
- Maintains exploit metadata (severity, type, payload, etc.)

### 2. **Seek & Auto-Attempt**
- **SEEK Button**: Searches for exploits for a given target URL
- Queries local registry and network peers simultaneously
- Auto-attempts discovered exploits (if enabled)
- Prioritizes by severity (Critical ‚Üí High ‚Üí Medium ‚Üí Low)

### 3. **Network Sharing**
- P2P broadcast of successful exploits
- Periodic sync with peers (configurable interval)
- Exploit filtering and grouping
- Statistics and monitoring

## Integration Steps

### Step 1: Import in HadesAI.py

Add these imports at the top of `HadesAI.py`:

```python
# P2P Exploit Sharing
try:
    from p2p_exploit_sharing import P2PExploitSharer, ExploitSeeker, ExploitFinding
    from exploit_seek_tab import create_exploit_seek_tab
    HAS_P2P_EXPLOIT_SHARING = True
except ImportError:
    P2PExploitSharer = None
    ExploitSeeker = None
    ExploitFinding = None
    create_exploit_seek_tab = None
    HAS_P2P_EXPLOIT_SHARING = False
```

### Step 2: Initialize in HadesAI Class

In the `HadesAI.__init__()` method, add:

```python
def __init__(self, parent=None):
    # ... existing code ...
    
    # P2P Exploit Sharing
    self.exploit_sharer = None
    self.exploit_seek_tab = None
    
    if HAS_P2P_EXPLOIT_SHARING:
        self.exploit_sharer = P2PExploitSharer(instance_id=self.get_instance_id())
```

### Step 3: Add Tab to Main Window

In the tab creation section (around where other tabs are added):

```python
# Add Exploit Seek Tab
if HAS_P2P_EXPLOIT_SHARING and self.exploit_sharer:
    self.exploit_seek_tab = create_exploit_seek_tab(
        parent=self,
        exploit_sharer=self.exploit_sharer
    )
    self.tabs.addTab(self.exploit_seek_tab, "üîç Exploit Seek")
```

### Step 4: Connect to Network

When network sharing is enabled, initialize exploit sharing:

```python
def enable_network_sharing(self):
    # ... existing network code ...
    
    # Enable exploit sharing
    if self.exploit_sharer and self.network_node:
        self.exploit_sharer.network_node = self.network_node
        self.exploit_sharer.start()
```

### Step 5: Hook Exploit Discoveries

When exploits are discovered (in simulation or attack modules), register them:

```python
# When you discover an exploit
exploit = ExploitFinding(
    exploit_id=f"exploit_{int(time.time())}",
    target_url=target_url,
    exploit_type="sql_injection",
    severity="Critical",
    payload=payload_string,
    description="Successful SQL injection in login form",
    timestamp=time.time(),
    instance_id=self.exploit_sharer.instance_id,
    success=True,
    impact="Database access",
    remediation="Use parameterized queries"
)

if self.exploit_sharer:
    self.exploit_sharer.register_exploit(exploit)
```

## Usage

### Basic Usage

1. **In Simulation Tab**: After copying a link to a vulnerable application
2. **Click "SEEK EXPLOITS"**: Searches network for known exploits
3. **Enable "Auto-Attempt"**: Automatically tries discovered exploits
4. **View Results**: See detailed exploitation results in tabs

### Example Workflow

```
1. User enters target URL: https://vulnerable-app.test
2. Click "‚ö° SEEK EXPLOITS" button
3. System searches:
   - Local exploit registry
   - Network peers (via P2P)
4. Displays discovered exploits sorted by severity
5. If "Auto-Attempt" enabled:
   - Attempts each exploit in order
   - Stops on first success
6. Results shown with:
   - Successful exploits highlighted ‚úÖ
   - Failed attempts shown ‚ùå
   - Detailed analysis tab with payloads
7. User can "Share to Network" successful exploits
```

## Configuration

### P2PExploitSharer Options

```python
sharer = P2PExploitSharer(
    network_node=network_node,  # Connected network instance
    instance_id="unique_id"      # Unique identifier for this instance
)

# Control sync interval (default 30s)
sharer.sync_interval = 30

# Start/stop sharing
sharer.start()
sharer.stop()
```

### ExploitSeeker Options

```python
seeker = ExploitSeeker(
    exploit_sharer=sharer,
    simulation_engine=sim_engine  # Optional simulation engine for testing
)

# Seek exploits (async)
results = seeker.seek_and_attempt(
    target_url="https://target.com",
    callback=lambda r: print(r)
)
```

## API Reference

### P2PExploitSharer

```python
# Register a local exploit discovery
sharer.register_exploit(exploit_finding)

# Seek exploits for target
exploits = sharer.seek_exploits(target_url, callback=None)

# Get exploits by type
sql_exploits = sharer.get_exploits_by_type("sql_injection")

# Get critical exploits only
critical = sharer.get_critical_exploits()

# Network statistics
stats = sharer.get_network_statistics()
# Returns: {
#     'total_exploits': int,
#     'local_exploits': int,
#     'received_exploits': int,
#     'critical_count': int,
#     'high_count': int,
#     'exploits_by_type': dict,
#     'shared_count': int
# }

# Export/Import
sharer.export_exploits(filename)
sharer.import_exploits(filename)
```

### ExploitSeeker

```python
# Seek and attempt exploits
result = seeker.seek_and_attempt(
    target_url="https://target.com",
    callback=None
)

# Get search status
status = seeker.get_search_status(search_id)

# Cancel search
seeker.cancel_search(search_id)
```

### ExploitFinding

```python
@dataclass
class ExploitFinding:
    exploit_id: str          # Unique identifier
    target_url: str          # Target URL
    exploit_type: str        # sql_injection, xss, rce, ssrf, jwt_bypass, etc.
    severity: str            # Critical, High, Medium, Low
    payload: str             # Exploit payload
    description: str         # Human description
    timestamp: float         # Unix timestamp
    instance_id: str         # Which instance discovered it
    success: bool            # Whether it was successful
    impact: str              # Impact description
    remediation: str         # How to fix
    metadata: Dict           # Additional info
```

## Network Message Protocol

Exploits are shared via the P2P network using this message format:

```json
{
    "type": "exploit_sharing",
    "action": "share_exploit",
    "exploit": {
        "exploit_id": "string",
        "target_url": "string",
        "exploit_type": "string",
        "severity": "string",
        "payload": "string",
        "description": "string",
        "timestamp": float,
        "instance_id": "string",
        "success": boolean,
        "impact": "string",
        "remediation": "string",
        "metadata": {}
    },
    "source_instance": "string",
    "timestamp": float
}
```

## Seek Request Message

```json
{
    "type": "exploit_sharing",
    "action": "seek_exploits",
    "target_url": "string",
    "requester": "string",
    "timestamp": float
}
```

## Security Considerations

1. **Encryption**: All P2P messages use TLS encryption
2. **Trust Levels**: Exploits from untrusted peers are marked
3. **Verification**: Exploit signatures can be verified
4. **Quarantine**: Unknown exploit types can be isolated
5. **Audit Log**: All exploit sharing is logged

## Troubleshooting

### No Exploits Found

- Check if Network Sharing is enabled
- Verify target URL is accessible
- Check if any peers are online

### Exploit Sharing Not Working

- Verify P2P network is connected
- Check network node is initialized
- Review logs for connection errors

### Auto-Attempt Failures

- Verify target is actually vulnerable
- Check if exploit payload matches target
- Try manual attempt first

## Examples

### Registering a Discovered Exploit

```python
from p2p_exploit_sharing import ExploitFinding
import time

exploit = ExploitFinding(
    exploit_id=f"sql_injection_{int(time.time())}",
    target_url="https://target.com/login",
    exploit_type="sql_injection",
    severity="Critical",
    payload="admin'--",
    description="SQL injection in login form bypasses authentication",
    timestamp=time.time(),
    instance_id="instance_001",
    success=True,
    impact="Full database access",
    remediation="Use parameterized queries and prepared statements"
)

exploit_sharer.register_exploit(exploit)
```

### Seeking Exploits with Callback

```python
def on_exploits_found(exploits):
    for exploit in exploits:
        print(f"Found {exploit.exploit_type} ({exploit.severity})")

exploit_sharer.seek_exploits(
    "https://target.com",
    callback=on_exploits_found
)
```

### Auto-Attempt Exploits

```python
result = exploit_seeker.seek_and_attempt(
    "https://target.com",
    callback=lambda r: print(f"Status: {r['status']}")
)

print(f"Total attempts: {len(result['attempts'])}")
print(f"Successful: {sum(1 for a in result['attempts'] if a.get('success'))}")
```

## Performance Notes

- **Seek Performance**: ~100ms for local search
- **Network Sync**: ~500ms for P2P broadcast
- **Memory**: ~1MB per 1000 exploits
- **Thread-Safe**: All operations are thread-safe

## Future Enhancements

- [ ] Machine learning for exploit prioritization
- [ ] Exploit mutation and polymorphism
- [ ] Temporal analysis (exploit age/freshness)
- [ ] Target profiling and fingerprinting
- [ ] Automated payload generation
- [ ] Exploit chain discovery
